#第二周 
##一、学习笔记
##5.1哈希表、映射、集合的实现与特性
1. Hash table
哈希表（Hash table），也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。<br>
它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。<br>
这个映射函数叫做散列函数（Hash Function），存放记录的数组叫做哈希表（或散列表）。
工程实践：电话号码簿、用户信息表、缓存（LRU Cache）、键值对存储（Redis）
Hash Function：举例，lies：每个字符串的ASCii码mod一个数得到9，放到index为9的位置
Hash Collisions：不同的要存储的数据，它经过哈希函数之后会得到一个相同的值，对应的下标相同，则发生hash碰撞。那么说明，该下标处要存多个元素，一个的话依次往下面存占别人的位置，
当然最好的一种方式，或者是相对在工程上常用的方式，就是再增加一个维度，这个位置存多个数，也就是从这里拉出来一个链表，这样的方法叫做拉链式解决冲突法
2.Map和Set：在真正的工程代码里面，我们经常在用的话就不再试哈希表了，而是在哈希表基础上抽象出来的。经常抽象出来使用的比较多的是Map和Set
Map:key-value对，key不重复
new HashMap()/new TreeMap()
map.set(key,value)
map.get(key)
map.has(key)
map.size()
map.clear()
Set:不重复元素的集合
new HashSet()/new TreeSet()
set.add(value)
set.delete(value)
set.has(value)
区别：map的话是键值对，而key是不重复的，value可以重复，它是一个键值对的关系；set的话是不重复的元素的集合，这个的话就没有键值对，就是一个单个的元素，这里面单个元素就是不重复的，这边的话是Key不重复
Hash实现其实就是在背后建了一个hashMap，add时把元素放到key，随便放一个Object作为占位的value，remove也是调用map.remove，背后实现其实就是嫁接在hashmap上。这种实现有很多冗余元素在里面
treeMap和treeSet的实现都是用红黑树实现的，所有操作的时间复杂度都是log(n)
课后作业
写一个关于 HashMap 的小总结。（重点看put和get）node分为hashNode和treeNode
##5.2
排序：所有面试的时候，排序不要自己写，直接调Arrays.sort()即可
有效的字母异位词：1.暴力：sort,sorted_arr是否相等  O(NlogN) 2.hash，map-->统计每个map的频次，技术处理：第1个单词碰到相应计数+1，第2个单词碰到相应计数-1，最后判map是否为空；用长度为256的数组来计数，因为ASCII码的范围为0-255，长度为256的数组来计数，其实它也是一种简化了的hash表，只不过它的hash函数是它的ASCII码的值
字母异位词分组：排序，用排序后的结果作为key，存到一个map里面，最后把map的值归类之后输出
两数之和：hash表，a,b--> a+b == target --> for each a:check(target - a) exists in nums
学习方法：养成收藏精选代码的习惯（把题目中多种解法及要点罗列起来），每次面试之前会看一下这些代码。这样真正面试下笔如有神，写出来是多种解法，且皆是比较优化的代码
         养成这种总结代码的习惯，同时形成自己的这种至少是算法和数据结构的一个精选代码库的概念，同时还可以把它放到github上面
##6.1树、二叉树、二叉搜索树
###树：
现在树踏到二维结构，回顾链表等一维结构，链表有头、尾，还有next指针不断往后指，这叫单链表。如果是双链表，还有一个前继指针往前指。链表最大的问题就是查询的时候太慢，要O(n)的时间复杂度。正是这个原因，后来就出现了跳表结构，加上了更快的索引，比如从头指针跨到第二个节点。如果要加速的话，最关键在于升维。
要升维的话，接下来就可以看我们的二维的数据结构，常见的是什么，那么其实就是树和图。讲树之前想给大家引出的一点是，在单链表这里的话，如果它的next指针，很多时候你再想想，它不再是一个next,而是多个next，有next1、next2、next3指向多个结点的话，它就变成一课树了
树的基本定义以及相应特点：

树节点的定义：
public class TreeNode{
  public int val;
  public TreeNode left,right;
  public TreeNode(int val){
    this.val = val;
    this.left = null;
    this.right = null;
  }

}
为什么会出现树：
人类本身生活在一个三维的世界里面、思维的世界里面当然也包括二维，所以人类本身的工程实践，其实是在二维基础上解决的，而树本身的话就是人经常会碰到的一种情况
AlphaGo、各种棋类游戏（星际争霸也类似），选手开始下了以后，这个棋盘状态就是向外扩散成不同的状态，每个不同的状态再往下面走，棋盘的状态本身的话它也是一个树形结构。
三子棋，空棋盘是开始状态，每个人可以走不同步，走了以后棋盘就往下继续扩散出不同的状态，形成第二层、第三层、第四层的树的结点，
到了最后所谓的叶子结点，就是这个棋盘的某一终极形态，这个终极形态肯定就是不能再下了，其中有一方赢了或者输了或者是和棋的状态。

而本身的话不同的棋它的树状的空间，我们叫做它的状态树的空间。同时还有一个叫做博弈的空间，也可以叫做你的decision tree叫决策树的空间的复杂度不一样，最后决定了这个棋或者这个游戏，它的复杂度。
比如说三子棋肯定是相对比较简单，跳棋就相对更难一点，国际象棋已经很难了，再到后面中国象棋更难，还有日本象棋、韩国象棋，再到最后就是所谓的围棋，以至于围棋使用alphaGo在这么大一个空间里面去找它的最优解情况

树的遍历：如果这是一棵非常基本的树，没有任何特征的话，就它的里面的结点全都是无序的话，你要查找一个元素的话就必须要遍历，你遍历的话就是什么，把所有的结点都走一遍，怎么走，其他的数据结构循环一遍，一直循环到没有对吧。
因为它树状的话会有左子树右子树这么一种情况，那就类似的递归去把它反复的求证。那么递归的代码的话也非常简单，就左中右遍历。为什么叫这种结构？就是因为你要查自己的根结点的值，同时你还要访问你的左子树和右子树，总共需要三句语言。
这三句语言的顺序，最后就变成了不同的遍历方式。我们把它简单归类为
二叉树的遍历Pre-order/In-order/Post-order：根在左右结点的相对位置有前、中、右，则有三种遍历
1.前序Pre-order：根-左-右
2.中序In-order：左-根-右
2.后序Post-order：根-左-右

可以看到
我们整个遍历的话，这里基本上就基于递归的。为什么基于递归？
给大家讲一下，就是树的定义本身的话，它没法有效地进行所谓的循环，后面会讲，可以强行进行循环，比如说用广度优先遍历。
但是很多情况下的话，你会发现它这种结构的话，写循环相对比较麻烦，而写递归调用相对比较简单。
可以看到不同的序的遍历，其实严格说来就四行语句，非常的漂亮，也非常的简洁
所以树的各种操作的话，大家一定不要怕递归，而且要拥抱递归，或者是爱上这么一个递归的形式
###二叉树：儿子结点只有2个


树和图最关键的差别：看有没有环，如果它这一个结点本身的话，只连到新的儿子结点，永远都不会走回去，为树；如果有指针指回去，那就相当于会形成一个环，形成环的情况下，按照定义不称为树，而是叫做图
但在特殊化情况下，可以简化的理解为：Linked List是特殊化的Tree（因为链表有两个next指针），Tree是特殊化的Graph（没有环的图就是树）
###二叉搜索树Binary Search Tree：
二叉搜索树，也称二叉排序树、有序二叉树（Orderd Binary Tree）、排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的树：
1.左子树上所有结点的值均小于它的根结点的值
2.右子树上所有结点的值均小于它的根结点的值
3.以此类推：左、右子树也分别为二叉查找树。（这就是重复性！）
中序遍历：升序排列
二叉搜索树常见操作(都是O(logN))
1.查询（O(logN)）
2.插入新结点(O(logN))：查找的到：count+1；查找不到：放在最后找到的位置left（小于当前就放左）或right（大于当前就放右）
  （创建）：创建一个空树，把所有结点依次调用插入即可
3.删除(O(logN))：叶子结点：直接删掉即可；根节点或者某子树的根节点：删除目标结点，拿最近的结点补充，一般来说取第一个大于当前结点的结点替换上去
特殊情形：树退化成一根棍子，变成单链表
思考题：access 、search、insertion、 deletion都是O（n），加速的话，把它配平，变成平衡二叉树
树的面试题解法一般都是递归，为什么？
##6.2实战题目解析：二叉树的中序遍历
1.binary-tree-inorder-traversal
2.binary-tree-preorder-traversal
3.n-ary-tree-postorder-traversal
4.n-ary-tree-preorder-traversal
5.n-ary-tree-level-order-traversal  其实就是广度优先遍历