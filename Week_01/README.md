学习笔记
#第一周 
##一、学习总结：
###1.效果
总的来说，效果一般。我遇到一个问题有点爱死磕，导致占用很多时间，效率低，所以五毒神掌每道题现在只过了两遍。
###2.学习过程
我是先看的老师的录播，然后着手做习题的，用习题来检验学习效果。
###3.感受
感觉算法题真的难，以前没有过这方面的训练，底子太薄，一做起来题目一点思路都没有，做了半天看答案。看了答案遇到不会的又看看答案，好虐心。
###4.收获
掌握了数据、链表、栈的一些简单增、删、改、交换操作，遇到一些特殊问题会去想用栈解决
##二、学习笔记

###2.1训练环境设置、编码技巧和Code Style（略）
常用工具配置
基本功和编程指法（Best Practices/Top tips）
###2.2时间复杂度和空间复杂度分析
       /运行时间   /占用空间
现实在写工程代码的时候，经常要分析的地方，通过读程序来判定它的时间复杂度的方式。
1. 首先时间复杂度大概有哪几种？
时间复杂度表达的话，经常用这里所谓的Big O notation来代表
Big O notation（七种），这里的O的话表示它的复杂度是n的怎样的一个函数
最常见的七种时间复杂度：
O(1): Constant Complexity 常数复杂度
O(log n): Logarithmic Complexity 对数复杂度
O(n): Linear Complexity 线性时间复杂度
O(n^2): N square Complexity 平方
O(n^3): N cubic Complexity 立方
O(2^n): Exponential Complexity 指数
O(n!): Factorial 阶乘
注意：只看最高复杂度的运算，不用考虑前面的常数系数
怎么来看这样一个时间复杂度？最常用的方式，就是直接看这个函数，或者是说这段代码的话，它根据n的不同情况，它会运行多少次。
O(1)： int n = 1000; System.out.println("..."");
O(1): int n = 1000;System.out.println("..."");System.out.println("do..."");System.out.println("and more..."");
O(N): for(int i = 1;i<=n;i++){System.out.println("..."):}
O(N^2): for(int i = 1;i<=n;i++){
for(int j=1;j<=n;j++){
System.out.println("..."):
}}
O(log(n)): for(int i=1;i<n;i=i*2){System.out.println(""...");}
O(k^n): int fib(int n){ if(n<2) return n; return fib(n-1)+fib(n-2);}
Fibonacci数列球它的第n项的话，这里用了一种递归的形式，递归程序在递归的时候，怎么计算它的时间复杂度，答案是k的n次方。
这里k是一个常数，也就是你可以认为是2的n次方，或者3的n次方，其实是一样的，就是k的n次方，它是指数级的。
所以简单的递归求Fibonacci的话，它是非常慢的，指数级的时间复杂度

2. 时间复杂度曲线：
见视频的图
从这个地方可以看到n如果比较小的时候，也就在10以内的话，不同的时间复杂度其实都差不多。
但是如果当n开始扩大，那这个图的话是在5以内都差不多，
如果当n增大的话，会发现指数级的话，它涨得是非常快的。
也就是说当你在写程序的时候，如果你能够优化时间复杂度。
比如说从2的n次方降到n平方的话，那么从这个曲线来看的话，当你在较大的时候，你得到的收益是非常高的。
从图可以看到，n越大的话，它的差别可谓是天壤之别。

伏笔or反复强调的地方：
第1点：各位在写程序的时候，一定要对自己程序的时间和空间复杂度，有所了解，而且是养成习惯。写完了之后，能够下意识地分析出这段程序的时间和空间复杂度
第2点：能够用最简洁的时间和空间复杂度完成这段程序的话，基本上是一个顶尖职业选手的必备的素养
从图可以看到，如果时间复杂度写砸的话，其实你带给公司的程序或者机器或者说资源的损耗，那么随着n的增大的话是成百上千的一个增加，
而如果你能够简化的话，对公司来说是节约很多成本，而且这些节约成本的话，其实就是改动一些代码所带来的，可谓是对于你来说影响力非常大

计算:1+2+3+...+100
方法一：从1到n的循环累加 ：O(n)
y=0
for i= 1 to n:
  y+=i
方法二：求和公式sum=n(n+1)/2：O(1)
y=n*(n+1)/2
更复杂的情况：递归
关键就是要了解它的递归总共执行了语句多少次。
如果是循环，很好理解，n次的循环就执行了n次。递归的话其实它层层嵌套下去怎么办？
其实，很多时候我们要借助的是，把递归它的执行顺序，画出这么一个树型结构，我们称之为它的递归状态的递归树，
或者就是状态树这样一个东西。

Fib:0,1,1,2,3,5,8,13,21,...
F(n)=F(n-1)+F(n-2)
面试（直接用递归）：一定不要在面试中直接这么写
int fib(int n){
if(n<2) return n;
return fib(n-1)+fib(n-2);
}
可以加一个缓存，把这些中间结果能够缓存下来，或者是直接用一个循环来写，写完这整个Fibonacci数列求n项的
状态树见视频图：
f(6)=f(5)+f(4),f(5)=f(4)+f(3),f(4)=f(3)+f(2)
计算f(6)会引出两个分支，分别是f(5)和f(4)。会发现要计算6的话，就会变成至少要计算一个F5，也要计算一个F4，至少是多出两次运算
同理F5可展开为计算F4再加上F3，F4可展开为计算F3再加上F2
可以看到两个现象：
第一个现象的话就是它每多展开一层的话，运行的节点数就是上面一层的两倍，它的节点数也就是它的执行次数的话，是按指数级递增的，
所以下到最后一层，它就变成2的n次方，大概这么一个数量级的节点，那么肯定最后总的执行次数的话，就是变成指数级了
第二个现象的话就是有重复的节点，出现在我们执行的状态树里面，F3被计算了很多次，同时F1和F2也被计算了很多很多次，正是因为有这么多大量冗余的计算的话，导致求第6个数的Fibonacci数的话
变成了2的6次方这么一个繁复的时间复杂度。所以这里你可以看到它的时间复杂度展开的话，是非常相对来说是比较恐怖的，或者是事倍功半的

3. 主定理：它是用来解决所有递归的函数，怎么来计算它的时间复杂度。任何一个分治或者是递归的函数，都可以算出它的时间复杂度，怎么算，就是通过这个主定理。
本身比较复杂的话，那怎样化简为实际可用的办法。
其实关键就是这四种，大家记住就可以了 
一般在各种递归的情形的话，有这四种情形，是在面试和大家平时工程中农会用上的，大家把这四种的话记住即可。
Binary Search/二分查找:   T(n)=2T(n/2)+O(1)  O(log n)
一般发生在一个数列本身有序的时候，在有序数列找到要的目标数。所以每次都一分为二，只查一边这么下去的话，最后它时间复杂度是log(n)，所以二分查找是log(n)的时间复杂度
Binary tree traversal/二叉树遍历：  T(n)=2T(n/2)+O(1)  O(n)
如果是二叉树的遍历的话，它为O(n)，因为通过主定理我们可以知道，它每次要一分为二，但是每次一分为二之后，每一边它是相等的时间复杂度这么下去，
最后它的一个递推公式就变成了图中T(n)=2T(n/2)+O(1)这样，最后的话用主定理可以推算出，它的运行时间为O(n)的。
当然的话这里有一个简化的思考方式，就是二叉树的遍历的话，我们会每一个节点都访问一次且仅访问一次，所以它的时间复杂度就是O(n)的
Optimal sorted matrix search/排好序的二维矩阵进行二分查找： T(n)=2T(n/2)+O(log n)  O(n)
同理用主定理可以得出，最后时间复杂度是O(n)的，记住就好
Merge sort/归并排序：T(n)=2T(n/2)+O(n)  O(nlog n)
所有排序最优的办法就是nlog n的，所以归并排序也是nlog n的时间复杂度

二叉树遍历-前序、中序、后序：时间复杂度是多少？ O(n)
图的遍历：时间复杂度是多少？   O(n)
搜索算法：DFS/深度优先、BFS/广度优先 时间复杂度是多少？   O(n)
每个节点会访问一次且仅访问一次，所以它的时间复杂度是线性于节点总数，也就是O(n)的时间复杂度

二分查找：时间复杂度是多少？log n

4. 空间复杂度
 主要有两条原则
 数组的长度:如果代码里面开了数组，那么数组的长度，基本上就是你的空间复杂度
 递归的深度（特殊说明）:如果是有递归的话，那么它递归最深的深度，就是你的空间复杂度的最大值
 当然，如果你又是递归里面又开了数组，那就是两者之间的最大值就是你的空间复杂度

5. 实例分析
pa-lou-ti-by-leetcode/climbing stairs/爬楼梯：
          时间复杂度    空间复杂度
简单递归   O(2^n)   O(n)
记忆化递归  O(n)   O(n)
尾递归   
动态规划   O(n)   O(n)
斐波那契数  O(n)   O(1)
7. 参考链接
如何理解算法时间复杂度的表示法
Master theorem
主定理

###3.2移动零
题目练习步骤：
1.5~10分钟：读题和思考思路,把所有可能的方法在题目上面整理出来，后面再比较它们，得出最好的思路
2.有思路：自己做和写代码，写的时候把所有方法都实现再执行测试样例通过(最后执行第5步五毒神掌)；不然，马上看题解！
3.默写背诵、熟练
4.然后开始自己写（闭卷）
5.五毒神掌
6.feedback
  老师codeReview
  看国内优秀题解、看国外的discuss优秀题解
核心思想：第一升维，第二空间换时间
###3.3
盛水最多的容器：枚举法、左右夹逼
爬楼梯：优化的思路：升维、空间换时间
懵逼时候：暴力？ 基本情况？ ，关键是找最近重复子问题（找重复性、找出递推公式），因为计算机/CPU只能执行 if else 、 for while 、 recursion
###3.4
两数之和：暴力求解、hash
3数之和（高频老题、面试官会避免）：暴力：三重循环、hash：两重循环+hash、夹逼/双指针：因为不需要下标，可以排序后夹逼；反馈：通过一些边界条件，加速代码
面试时：和面试官讨论的很好，另外的话把暴力求解、哈希表和双指针都先概述了一下，那么他们各自的方法时间复杂度也能够分析对，同时一气呵成写出这么一个代码，那么可能是最顶级的候选人
LinkedList:所有的LinkedList的题目的话，第一它解法非常固定，主要就是熟能生巧，它没有很多算法的东西，关键就是各位要熟悉怎么把next指针换过来换过去，和把prev指针换过来换过去。
要熟悉的办法就是多做，没有任何巧妙的地方。五遍刷题法，面试之前刷高频题。因为链表题虽然简单，但是一不小心代码很容易写复杂
1.reverse-linked-list
2.swap-nodes-in-pairs
3.linked-list-cycle 着重:hash、快慢指针：慢指针每次动1步，快指针每次动2步，快指针和慢指针是否重叠在一起，重叠有环，没有无环
4.linked-list-cycle-li
5.reverse-node-in-k-group

###4.2
最近相关性—>栈：类似洋葱，一层一层从中心，然后向外向外；打开洋葱的话，必须从外层剥一直剥到最里面，然后看最里面是什么。很多现实中的事情反映到工程里面都具有这种从外向内或者从内向外逐渐扩算，而且最外层和最外层是一对，最内层和最内层是一对，把这个称为最近相关性。这个要想到用栈
先来后到—>队列：讲公平性
有效的括号：1.暴力求解：不断replace匹配的括号；2.Stack
最小栈：两个栈：一个维护出入关系、一个维护最小栈去实现它的代码
两个栈或两个队列解决一些特殊性的数据结构问题，还有一类面试题只用栈来实现队列或者只用队列来实现栈，那就是用两个队列，每次先进先出都去到另外一个队列再出去，或者你要用栈来实现队列的话
就用两个栈,每次先进后出的话,就压到另外一个栈去,把它顺序再倒腾一遍
柱状图中最大的矩形:1.暴力求解,2.stack:维护一个栈，栈里面的元素从小到大排列，从小到大指的是从栈底到栈顶去从下到上是从小到大排列的，关键是要掌握压栈、出栈、还有结算的条件和时机，一般出栈即结算
滑动窗口最大值：所有滑动窗口题都用一个队列去求解，这里的队列是一个双端队列。1.暴力求解  2.deque(siliding window) 3.双指针

