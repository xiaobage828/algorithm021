#第七周 
##一、学习笔记
###13.1 字典树（Trie树）的基本实现和特性
#### 本节内容
那么在这里的话，我们主要是分为三部分来给大家讲：
1. 字典树的数据结构：首先字典树这个数据结构到底是什么样子的，为什么它会存在。
2. 字典树的核心思想
3. 字典树的基本性质

#### 复习树（略）
那么我们首先来复习一下树
#####树Tree
1. 定义
   二叉树
2. 层序遍历
3. 深度优先搜索
#####二叉搜索树
1. 定义
   任何一个结点，它的左子树的所有的结点都要小于这个根结点，它的右子树的所有的结点都要大于根结点，且对于它的任何子树同样地以此类推，对于任何子树都满足这样的特性。这个就是所谓的二叉搜索树。
2. 特性：
   二叉搜索树如果是中序遍历（左根右）的话是一个升序的序列。
3. 二叉搜索树主要解决的一个问题就是查找的时候效率会更高。


#### Trie树
那么接下来我们看，还有一种情况，在现实中特别常见。但是在二叉搜索树来进行存储的话，并不是特别好解决这样的一个实际问题。
这个实际问题是什么？这样的一个实际问题，就是在搜索的时候，很多时候当你打了一个字母的前缀、或者你中文也类似，就比如说你打了一个周杰，一般人可能会觉得你是伦吗？对，就是周杰伦
同理英文的话就是you的话，就是有这么多可以感应出来的，
像这种所谓的词频的感应或者是由前缀来推后面的可能的词语这种形式的话。在现实中其实是用得非常多的，那么它应该用怎样的数据结构来表示？
接下来的话就来给大家讲所谓的字典树或者trie树了。它就是因为这样的一种情形来应运而生的。

那么我们首先看一下，各位可以先思考一下，如果你自己要来设计的话，应该会怎么设计，同时的话你自己来进行设计的话，你的数据结构应该怎么选？
这个比较难，你可以多想想，然后停一分钟左右，当然的话一般来说就是不求你得到最优解了，因为发明这些数据结构的人，都是世界上最顶尖的图灵奖获得者。

那么我们说完了，我们接下来看字典树它是怎么来进行设计的？
首先要实现这样的一种所谓的前缀感应出整个单词，这里的话我们就要改变，二叉树的结点里面的存储方式了。
在之前我们介绍不管是二叉树二叉搜索树的话，这个结点里面存的是全部的值，这每个结点存的就是整个一个数字也好、一个单词一个字符串也好，就是全部的字符串。
但是在这里的话，字典树一个最关键的点的话，就是每个结点不再是存这里的单词本身，就是没有一个结点存youtube、或者是youbank这样的东西，
而是把这个字符串拆成单个单个的字母，每个字母存在这个结点里面去了，
从这一点的话，大家就首先要打破之前对树的认识，就是说它的存储是相对来说比较巧妙的，那么有了这个概念之后，接下来我把它整个定义先给大家叙述一遍。
####基本结构
字典树，即Trie树（多叉树），又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。
####基本性质
1. 结点本身不存完整单词：只存你下一个字符是什么，可以去到相应的路径；
2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；
3. 每个结点的所有子结点路径代表的字符都不相同：如果你两个是相同的话，你再下一步开始查找的话，程序就错乱了。

####结点的内部实现
![](Trie树结点的内部实现)
我们再来看一下结点里面的内部的它显示的结构，每个结点的话如果你是英文的话，那么毫无疑问它就会存到了下一个结点去的话，指向下一个结点的不同的指针，
这里的话它存储不再是用left和right来表示左右结点了，它就直接用什么，用相应的字符来指向下一个结点，比如说a的话表示如果你第一个字符是a的话，那么应该走到这个结点去，这里就是a这是英文，同时的话它除了abcdefg小写的，还有大写的所谓ABCDEFG，同时的话如果还有存在一些特殊符号的话，也可以放在这里，
所以的话如果是简单单词的话，同时不分大小写，你可以认为这里是26个分叉，就从a一直分到z对吧，abcdef一直到z，26个分叉出去，当然的话如果你要包含大小写，或者包括其他的话，可能是更多，同时如果是整个字符串的话，它的ASCII域的话是255，所以是255分叉。
一般来说的话，这里的话你可以认为是26分叉的一棵多叉树，到最后的话，如果它是叶子结点的话，相应这个字符就指向空，表示它这里的话就没有儿子结点了，对吧。
从这里你可以看出这棵树的话至少是一个26叉树，对吧。
当然的话你在这里的话可以动态来分配，一开始都是0叉的，出来一个单词的话就分叉出去一个，那么在最坏情况下的话，在最大可能的情况下的话会变成一个26叉树，所以的话它的空间是相对来说比较大的消耗。一层出去就是26，
那么我们再看它单词的长度，就是它的深度，在这种情况下，所以一般来说它查询是很快的，因为它要查多少次，各位，它要查的次数就是这个单词到底有多少个字符，它就查多少次，对吧。如果它单词只有两个字符，比如说to的话，它就只要从t走到这里，再走到这里，它只要走两次，最后就查到了to这个单词它所代表的，比如说它的频次到底是什么，那么单词len一般来说都不长，最多是10这么单词这么长，所以在整个字典里面，你们一般来说最多就查十多次，碰到就是长度为十几的这样一个单词，就一直查下来，这样的话就比，
比如说to你去整个字典里面去查，就算你排好序了，用二分查找的话，它的查找的时间也会比用排序，再用二分搜索来得快以及快不少，

####结点存储额外信息
数字：表示相应到这个结点所代表的单词，它的统计的技术就放在这个地方，后续的话可以给用户做相应的推荐
布尔（isEnd）：指的是到这个点为止，是不是有相应的单词存在。
当然了它的结点上可以存其他的额外的信息

####结点的核心思想
Trie树的核心思想是空间换时间。
利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

另外的话想这里提一点，正是因为它用了公共前缀，来表示这样一个路径的话，就可以非常天然地来解决，你只输了前缀的前几个字母的话，它就会把所有的以这个为前缀的候选词，都给你很方便地找出来。
从这里的话，其实就是比如说you就在这里，表示you这个东西，那么它下面所有的子树就代表了它所有单词，可以候选的单词，每个单词它的频次，你只要取出比如说前十大的频次对吧，然后就可以放在这个地方。那么这个业务功能，其实就相对来说可以比较好地解决。

####Tire 树代码模板
//leetcode
class Trie {
    class TrieNode {
        private TrieNode[] links;
        private boolean isEnd;
        public TrieNode(){
           links = new TrieNode[26];
           isEnd = false;
        }
        public boolean containsKey(char c){
               return links[c-'a']!=null;
        }
        public TrieNode get(char c){
               return links[c-'a'];
        }
        public void put(char c, TrieNode node){
               links[c-'a']=node;
        }
        public void setEnd(){
               isEnd = true;
        }
        public boolean getEnd(){
               return isEnd;
        }
    }
    private TrieNode root;  
    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode node=root;
        for(char c : word.toCharArray()){
            if(!node.containsKey(c)){
                node.put(c,new TrieNode());
            }
            node = node.get(c);
        }
        node.setEnd();
    }
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode node=searchPrefix(word);
        return node !=null && node.getEnd();
    }    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
         TrieNode node = searchPrefix(prefix);
        return node !=null;
    }
    public TrieNode searchPrefix(String prefix){
        TrieNode node=root;
        for(char c : prefix.toCharArray()){
            if(node.containsKey(c)){
                node = node.get(c);
            }else{
                return null;
            }
        }
        return node ;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */


####应用
1. 自动补全：谷歌的搜索建议
2. 拼写检查：文字处理软件中的拼写检查
3. IP 路由 (最长前缀匹配)：使用Trie树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。
4. T9 (九宫格) 打字预测： T9（九宫格输入），在 20 世纪 90 年代常用于手机输入
5. 单词游戏：Trie 树可通过剪枝搜索空间来高效解决 Boggle 单词游戏

###13.2 Trie树实战题目解析
####1. https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/  实现 Trie (前缀树)
https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/  添加与搜索单词 - 数据结构设计
####2. https://leetcode-cn.com/problems/word-search-ii/  单词搜索 II（讲解）
word search 有1和2都是非常经典的搜索题目.
word search的话在之前DFS的话都给大家说过，接下来我们看word search 2以及怎么能够优化这样的代码
![](word%20search2.jpg)
网格里面的单词必须是通过相邻的单元格里的字母构成，所谓的相邻就是上下或者是水平方向是相邻的。
那么这里的相邻表示什么，表示所谓的专业术语叫做四连通，比如说和a相邻的话就是上面的a、下面的k、左面的t、右边的e，所以是上下左右四连通。
如果把斜线也包含进来，比如说a和a、n和a也说可以相邻的，那么就叫做八连通图。
那么一般情况下，像这个题目的话，它给你说明了，反正就是四连通就行了。八连通和四连通的话，写法都差不多。后面的话代码会给大家讲。

1. words 遍历 --> board search:先写一层循环，然后每一个元素word看oath，o在这里面什么位置找到了之后，看它附近的ath是不是可以在这里找到。然后再看p这样一个东西,然后又去board里面先查一遍，p有没有，p在哪：没有，这种方式是可以写的。
   这种方式的复杂度是多少呢？O(N*m*m*4^k)
   首先的话它要循环整个words里面的对吧，我们就认为words里面是O(n)的话，那就放在这里n来了，
   board我们就直接是认为它是m*m的好了，同时的话你需要做的一件事情，就是对它的首字符去这里面进行深度优先的查找，看它有没有存在，那么它要做的一件事情，在这个地方的话，它会再去里面搜索一遍就变成m*m，每个的话都会在这个里面遍历一遍它相应的字符，最后看它有没有，这用这种办法写的话，就是所谓的O(n*m*m)的一种办法，
   而且它最坏的情况下的话，因为它每次首字母要这么查一遍，其他的字符的话会每次向不同的通路再分散出去，分散四次，所以这里的话其实还要再*4^k，这里的4表示它的通路为四个通路，k次方指的是单词，这个单词的平均的长度是多少
   所以它的总复杂度是这样子O(N*m*m*4^k)的
   这个方式大家要做的话，就做它的word search 1，把这个地方的-II的话就不要了，你去做word search 1，word search 1的话，那个题目的话数据没那么复杂，它的数据规模没那么大，你用任何傻搜的办法都可以解决，你直接做那个题目就行。
2. Trie：直接说Trie这种做法，以及我们来理解一下为什么它会更好
   首先Trie这个做法应该怎么弄？
   它的本质就是你在这里看，你与其通过这里开始来找和回溯，
   这里有个最关键的一个问题，就是说你所有不断地从任何一个字符开始查找的时候，都要判断它，比如说我从任何一个地方，从k开始好了，k的话，往上走到a就变成ka，
   关键是你要让搜索怎么快的话，就是你能够最高效地知道，而且最早地知道ka是不是在这些候选单词里面存在，且是任何一个单词的前缀，如果ka不是任何一个单词的前缀，那么ka找到这里就不用找了，那就直接找kn或者找ki或者kr或者是找kl对不对，
   同理从t这个单词假设向外开始搜索的话，t往上走到ta这时候可以很方便的一点看到，ta不是任何单词的前序，那就不用找了，对吧，
   就找te假设te是前序、也不是，那就不用找了，假设从e这里开始，en不是任何单词的前序，但是ea是这个单词的前序，那么我们就可以继续再往下找，同时找ea的话，其他的单词的前序就直接在这个单词里面，看它的剩下的前序是不是也照样去符合这么一种思路，
   所以用Trie的话就变成这样：
   a. 首先第一步所有的words全部放到一个Trie里面去，构建起这样一个字典树，当然这就可以让prefix全部可以高效地查询了，
   b. 接下来就是对于board对于二维的字母矩阵，所谓的进行一次DFS，它的起点的话就是遍历每一个字符，通过这个起点的位置开始做一个DFS，
      DFS产生了任何的字符串，去这里面查，看是不是它的子串，如果是它的子串且最后存在的话，那么就输出，不然的话就不输出 
      你后来的话我们可以证明它这个时间复杂度的话，在现实中会快很多，大部分情况下，它的子串，它的前序串的话不在这里面存在，所以就直接可以抹掉了，
   c. 它的时间复杂度怎么算：在这里的话我不把答案直接告诉大家，你用类似的这种方法，去找一次它的时间复杂度是多少，当然你可以先写，因为这个好处的话，它已经帮你提示了，就要Trie就写。你可以先写，写完了之后你看这个程序对吧。
      你看到你的代码去分析它的时间复杂度是什么，然后你最后放在你的作业和总结里面去。
      因为像这种分析时间复杂度的话，像类似于这种样子分析时间复杂度的话，算是面试题中已经是要求最高的一种情况了。要是你自己可以琢磨出来的话，那么所有在面试题中，在面试的时候让你分析时间复杂度，你都是没有问题的，所以你们自己去完成这个。
   d. 代码:
      你首先的话把Trie的之前那个题目，上一个题目实现Trie的代码先要复制过来。
      因为的话你至少要用Trie对吧，然后循环这个words，把里面的全部单词都加到Trie里面去，
      接下来的话就开始遍历二维的字符矩阵，以它里面的每一个字符作为起点，开始做DFS，做DFS的话就是上下左右开始进行扩散，扩散出来的每一个中间的单词串的话，都去Trie里面查找，看它是否存在，是否有前序，然后最后的话就得出一个结论。
   e. 优秀题解: https://leetcode-cn.com/problems/word-search-ii/solution/dan-ci-sou-suo-ii-by-leetcode/  官方题解
####3. Search suggestion - system design

###13.3 并查集(Disjoint Set)的基本实现、特性和实战题目解析
并查集的部分的话讲的内容其实不多，并查集属于一种怎么说，比较跳跃式的数据结构，也就是说你不会就是你压根都不会，你要是一会的话就会用就行了。它没有太多让你在上面进行发展的空间，或者是需要像动态规划或者是之前的那种各种搜索一样，有非常强的随机应变和在上线进行自由发挥的空间，
所以我们这里的话主要就是把它的情景和它的实现的代码告诉大家，那么大家主要就是调用现成的代码，就是把模板记号之后直接套上去用即可，也就是说这类题目基本上比较死。

我们来看并查集用的一个东西是什么，如果没听过的同学的话，肯定就觉得这个名字很玄乎吗
####适用场景
它解决的场景就是组团和配对的问题，也就是说在有些现实的问题中，你需要很快地判断这两个个体是不是在一个集合当中，当然我这么讲的话是有点抽象的。
很多时候就是说你和他是不是朋友这么一个问题，如果是在社交网络里面以及判断两个群组之间是不是一个群组以及很快地合并群组，所以需要用这样的数据结构。
那么在这里的话希望大家可以暂停一分钟，假设让你们自己来实现，比如说实现微信上的好友和所谓的朋友圈的功能，以及分析这两个人是不是好友这么一个问题，你们应该如何实现？
大概你们先思考一下，可以暂停一分钟在这里，让你非常快地能够判断a和b到底是不是朋友，以及可以支持一些操作，比如说把a变成b的朋友，类似于这样一个问题，
假设我们有n个人好了，从0到n-1，你可能会想到比如说用一个set或者用一个dictionary表示这里面的人都是朋友，类似于这样的问题，这时候你会发现你就会出现一种问题，就是你可能要建多个set，
比如说他两两一个朋友，但是互相的话不是朋友的情况，以及在后来的话你要合并set之类的这样的操作，以及你很难分辨，比如说这一堆朋友的一个群组，它是属于比如说第几个群之类的问题，
这样的话基于这种原因，当时就发明了一种数据结构，这个数据结构的话叫做并查集，专门来解决这个问题。
- 组团、配对问题
- Group or not?
- 连通性的问题，即将一个图中连通的部分划出来。
####基本操作
我们首先看并查集，也就是要解决的这类场景，主要有三个要实现的函数：
一个实现的函数就是新建一个集合，新建一个集合，其中包括s个单元素的集合。它要做的一件事情就是说，我随时都可以创建一个集合，这个是毋庸置疑的，不管你用数组还是用set，反正一开始肯定要支持一个操作，创建一个集合。
接下来要做的一件事情就是你可以指定两个元素，然后第二个操作就是能够很方便地将两个元素，组成到一个集合里面去，如果x和y分别属于不同的集合的话，实际上就是要把x和y所在的集合进行合并。那么经常会碰到的问题就是说我属于其中群a，另外一个y属于另外一个群b，然后我们两个群合并了，x和y现在就可以变成是同一个群了。
第三个的话就是来判断给定任何一个元素，find(x)就是来判断它应该属于哪一个集合，以及找到集合的老大，或者叫做集合的代表。
那么这三种操作加在一起就是并查集常见的一个操作。
- makeSet(s):建立一个新的并查集，其中包含s个单元素集合。
- unionSet(x,y):把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。
- find(x):找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要它们各自的代表比较一下就可以了。
并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。
#### https://leetcode-cn.com/problems/number-of-provinces/  朋友圈（已下线）
以朋友圈来讲解，见习题
####实现
那么并查集是什么呢？我们接下来就给大家非常详细系统地来介绍一下，并查集这个数据结构。
#####初始化
![](并查集-初始化.png)
并查集它本身它的实现的一种形式如此，首先的话我们首先从图形上面给大家说一下整个并查集它的原理，一开始的话每一个元素，它拥有一个parent数组指向自己，每一个元素，它都有一个所谓的parent这么一个数组，它指向自己表示它自己的话就是自己的集合或者自己是自己的老大，就这个意思，
#####查询、合并
![](并查集-查询、合并.png)
接下来所谓的合并和查询的一个操作，如何查询对任何一个元素，看它的parent再看它的parent就一直往上，直到它的parent等于它自己的时候，说明找到了它的领头元素，就是它的集合的代表元素，那么就表示这个集合是谁。
如何合并？比如说我们要把这个集合和这个集合进行合并，对不对。把这两个集合进行合并，要做的一件事情就是找出集合的领头元素，在这里是a，和另外一个集合，它的领头元素在这里的话就是e对吧。
e就在这个地方，然后将parent[e]特意指向a，或者将parent[a]指向e，这两个都是一样的操作。要么把e的parent指向a，或者是把a的parent指向e都行。那么假设我们把e的parent指向a的话，那么就这么指过去，最后的话就把这两个进行所谓的合并了。
#####路径压缩
![](并查集-路径压缩.png)
还有一个叫做所谓的路径压缩，这里的话我们看到d的parent是c，c的parent是b，b的parent是a的话，那么我们可以直接把这条路上的所有的元素，它的parent都指向a，这样的话还是和原来的表是一样的，但是它的查询的时间的话会快不少。原来的话a你要查它的集合的领头元素是谁，要往上走一步走两步走三步，在这里的话就只要一步即可了。
那么关于路径压缩的话，大家记下来就可以了，以及它在图形上是怎么表示的，在这里大家先记住。
####并查集代码模板
我们接下来就看代码，看代码的话理解起来就更加全面了一点。本身的话首先给大家讲一个，这个的数据结构，本身的话就是有所谓的跳跃性的，也就是说你不用太多的思考，就是它怎么想到用这种办法来做的。因为的话它是当时根据实际情景的话，想了很多不同的办法，最后不断地优化，而且的话也是好多年进行的积累。
接下来的话还有一点就是说本身话它的实现的话也相对比较巧妙，所以的话最关键就是大家首先理解，同时的话把它的代码多看几遍记熟练了。
因为我自己在学的时候，对于并查集本身的话其实是相当于上了一个比较大的一个台阶，但它最后用起来的话是相对来说比较明显的，就是说使用场景或者哪些题要用并查集，基本上是一看这个题目意思就知道。
它要判断两两的元素是不是在一个集合，就用并查集就行了，然后把并查集的代码打过去，然后就可以这么解决这个问题了。
// Java
class UnionFind { 	
    private int count = 0; //集合或组的个数
	private int[] parent; 	
	public UnionFind(int n) { 		
	   count = n; 		
	   parent = new int[n]; 		
	   for (int i = 0; i < n; i++) { 			
	      parent[i] = i;		
	   }	
	} 	
	public int find(int p) { 		
	    /*
	    *路径压缩
	    */
	    while (p != parent[p]) { p不是代表结点		
	      parent[p] = parent[parent[p]];//将p的祖父结点作为p与p的父亲结点的共有父结点，该步实现了路径压缩
	      p = parent[p];//将指针指向p的新父结点
	      //重复上述过程，将所有结点指向公共的父结点，直到p指向代表结点即跳出循环
	    }		
	    return p; 	
	}	
	public void union(int p, int q) { 		
	     int rootP = find(p); 		
	     int rootQ = find(q); 		
	     if (rootP == rootQ) return; 		
	     parent[rootP] = rootQ; 		
	     count--;	//每次合并
	}
}

####实战题目
##### 1. https://leetcode-cn.com/problems/number-of-provinces/  朋友圈（已下线）
   a.DFS，BFS （类似 岛屿问题）
   b.并查集
##### 2. https://leetcode-cn.com/problems/number-of-provinces/ 省份数量
##### 3. https://leetcode-cn.com/problems/number-of-islands/ 岛屿数量
##### 4. https://leetcode-cn.com/problems/surrounded-regions/ 被围绕的区域


###高级搜索
搜索是一个所谓的状态树的问题
高级搜索的话，其实是前面讲的搜索内容的一个进阶。这里的进阶内容的话，一般来说可能要求大家对之前的话要比较熟悉，所以这里的话我先给大家进行复习。
如果大家在看我后面要讲的复习的部分的话，还是对之前我们讲的简单的搜索，比如BFS、DFS不是特别了解的话，我鼓励大家回去再看一遍。
####目录
- 剪枝
- 双向BFS
— 启发式搜索（A*)
而且同时的话，这里要讲的接下来，剪枝、双向BFS和启发式搜索，都是比较烧脑或者是高阶的一些内容，所以大家的话一定要记得可能要多看几遍，然后平时多想想把笔记都记下来。
另外的话如果大家对一些知识点的话，发现理解起来特别难的话，我给大家建议就是不用花很多的时间进行所谓的死磕，更加重要的是过遍数，也就是说一个知识点反复看起来，
比如说启发式搜索的话，我在第一次在大学中看的时候一直都没有看懂，到了我大学快毕业的时候，一个机缘巧合的关系，我平时有时候在想，想到了之后，就发现一下子就理解了。当然的话我在这里尽量给大家讲的深入浅出一点。
###14.1 剪枝的实现和特性
接下来我们来看之前讲过的搜索部分的话叫什么？之前讲过的搜素的话，其实我们都可以认为是所谓的初级搜索
####初级搜索
1. 朴素搜索
优化搜索
所谓的初级搜索的话就是傻搜或者暴力搜索。它主要可以优化的方向，或者是怎么把它变高级，主要是这两个领域，
第一个领域就是不重复和所谓的剪枝，这两者是相辅相成的，那么不重复剪枝，大家可以想就是第一Fibonacci问题，Fibonacci问题大家可以想到那个状态树是什么。
          如果你只是简单地写一个递归程序，没有进行任何判重的话，那么它有大量的重复的结点的计算，那么时间复杂度沦为指数级的。这个不清楚的话，都非常鼓励大家回过去自己再看一下。
      那么可以用的办法就是所谓的用数组来存它的中间值，或者是在这里可以看直接用顺推的办法，就是避免重复中间重复的状态，这就是把它的重复性给去掉。
      另外的话就是还有其他的更加高级的剪枝，我们在生成括号问题时候给大家来说。你也可以认为在Fibonacci的问题处理上，我们也进行了所谓的剪枝，这都是异曲同工的。
           所谓的剪枝就是整个状态树，这一个分支是没有必要的时候，那么我们就把它剪掉，不进行搜索，这种没有必要性是来自一个是重复，当然也有可能是我每次要找最优解对不对，那么有一个分支是次优或者不够优的，我们觉得肯定是不行的，那就把它剪掉。
那么另外一个优化的方向就在这里，它的搜索方向上还可以进行优化，之前已经讲过了，它的搜索方向的话主要是深度优先搜索和广度优先搜索两个方向。
          在这里的话，那么有经验的同学或者是练过不少题目的朋友，这时候你会发现它所谓的深度优先和广度优先，只是因为计算机数据结构里面有个所谓的先入后出的栈和先入先出的队列，导致了整个搜的时候是这两方面，
          但是你细想的话就是说广度优先可能还好一点，广度优先一般扩散到的都是距离最近的，但是深度优先的话其实就是傻搜，或者就是一路不回头，直到撞到南墙才回头继续对吧。
          那么它这种的话并没有所谓的按照优先级，或者是没有任何的智能性，那么在这里的话，我在接下来这个章节会给大家介绍优化的高级搜索的另外两种，
     一种是双向搜索，双向搜索你可以理解为，它从起点和终点分别做一个广度优先，然后在中间相遇，这样的话它的时间更快。
     另外一个就是启发式搜索，启发式搜索就不再是用栈，或者用队列了这种先入先出先入后出的形式，而是用一个优先队列放在这里面。而优先队列的话，它是按照这个结点，所谓它的优先级，也就是有些结点更可能会达到我们需要的结果的话，就先把它从队列里面拿出来进行搜索，我们这个就叫做启发式搜索，也叫作A*算法或者叫做优先级搜索。
2. 优化方式：不重复（fibonacci）、剪枝（生成括号问题）
3. 搜索方向：
   DFS: depth first search 深度优先搜索：傻搜
   BFS：breath first search 广度优先搜索：广度优先一般扩散到的都是距离 最近的
优化的高级搜索的另外两种
双向搜索：它从起点和终点分别做一个广度优先，然后在中间相遇，这样的话它的时间更快
启发式搜索：不再是用栈或者用队列了，这种先入先出先入后出的形式，而是用一个优先队列放在这里面。而优先队列的话，它是按照这个结点，所谓它的优先级，也就是有些结点更可能会达到我们需要的结果的话，就先把它从队列里面拿出来进行搜索，我们这个就叫做启发式搜索，也叫作A*算法或者叫做优先级搜索。
#####Coin change(零钱置换) 的状态树
![](Coin%20change(零钱置换)的状态树.png)
先给大家说一下这张图，这张图我想每个人都要记在脑子里面。当你在做一个搜索问题的时候，这个时候你一定要一下子在脑子里面会想到，大概有这么一个搜素树，这个题目是零钱置换问题。
零钱置换问题说的是什么？就是你有面值为125这样的零钱，去凑成一个总值为11（十一）的面值，问你不同的凑法有多少种吗？
那么它的递归树的话就是我先用面值为1的话，抽出来的话，剩下还需要出10一个子问题，它的分支在这里（视频圈了10的结点），
    当然我可以用面值为2的，它剩下就是9，9的话它的子分支在这个地方（视频圈了9的结点），
    或者我用5，剩下的话就是6，6的话分支就在右侧，
那么接下来递归树就是不断地向下展开了，
这时候你会发现所谓的搜索问题其实就是在它的整个状态树里面，做深度优先也好，广度优先也好，或者是优先级优先也好，
    最后找到我们要的比如说最优解，
    或者是统计它的分支的个数，也就是说所谓的到叶子的路径的个数，这就是所谓它的什么，总共有多少种不同的钱币的拼法，对不对。
    在这里一定要记得大家把这种数形结合的思想给利用起来。一想到搜索问题，在脑海里面就把这个图形给大家画出来，看到图形大家就想到，这是一个所谓的状态树的问题。
#####DFS代码
  -递归写法    
    见视频代码
  -非递归写法：用stack手动模拟
    见视频代码
#####BFS代码：用队列
    见视频代码
    
####剪枝
前面引语的话：所谓的剪枝就是整个状态树，这一个分支是没有必要的时候，那么我们就把它剪掉，不进行搜索，这种没有必要性是来自一个是重复，当然也有可能是我每次要找最优解对不对，那么有一个分支是次优或者不够优的，我们觉得肯定是不行的，那就把它剪掉。

我们现在就开始来讲高级搜索的第一个部分，所谓的剪枝。
剪枝的话就是前几页给大家讲的状态树了，大家在状态树进行搜索的时候，如果发现这个分支是已经处理过的，那么我们就把它暂存在缓存里面，整个分支的话就可以剪掉，不需要再手动进行计算。
    当然有些时候是分支的话不够好，所谓的叫做比较差的分支或者是次优的分支，我们也可以把它剪掉，这就是所谓的这种剪枝。
    之所以有这种枝条的形态，就是因为整个状态树的话是一种所谓的树和枝叶的形态。
![](剪枝.png)
那么在这里的话很多同学有可能会问了，那么现在计算机速度这么快的话，哪些问题状态空间还需要剪呢？
    这里想给大家讲第一Fibonacci问题，它其实状态空间就比较繁复了。
    另外的话就是很不幸在人类生活世界当中，具体的问题，它的状态树的空间大小一般来说都是比较恐怖的。
#####国际象棋
我给大家举一个例子，这就是国际象棋。当年的话，这一仗就是人类选手卡斯帕罗夫和计算机深蓝进行的一场对决，这个对决的话在90年代初那时候名噪一时。当时的话就是用普通的笔记本，用最基本的搜索再加剪枝和一些优化的算法，最后的话就战胜了卡斯帕罗夫，当然是险胜。
这个棋本身的话就是用的最朴素的搜索办法，本身的话它最后赢的棋谱，这一仗是1996年在费城2月10号，深蓝对阵卡斯帕罗夫。
这个是棋谱1指的是每个人走了一步，第2每个人走了两步，最后的话你会发现是每个人走了37步之后决出了胜局。
所谓的走37步就是这个状态树，它什么，它的深度是37，所以你可以看到就算它每一层深度的分叉就是两个分叉罢了，那就是2^37也是非常大的，当然这里不止两个分叉。比如说你可以走卒，你可以走这个卒或者是走马或者走象，那么它每次的分叉就接近在10左右了，所以你可以看到它的状态树空间是非常大的。
正是因为深蓝的话，就是进行了大量的剪枝，也说了一般来说比如说皇后走这个位置，最后皇后送掉了，那就是不好的位置，那么这个分支的话就直接被砍掉了。   
![](国际象棋对阵.png)
    我们来看一下象棋本身，象棋本身之所以有37层，这是一个复杂度，另外一个复杂度的话，它每一层的分治的话之前讲了是接近于10的。正是因为这样的话，它的程序就是异常复杂。到了90年代那个时候的话，随着计算机本身的发展，以及后来的话剪枝用得越来越好了，那么后来慢慢就攻克了这个棋。
![](国际象棋的状态树.png)
#####三子棋
为了更好地给大家说整个剪枝的一种办法，给大家说一下整个三子棋这块。
![](三子棋.png)  
    三子棋的话，我想大家上课的时候或者课间的时候，大家可能都玩过，初中的时候或者小学的时候就画一个3x3的棋盘，两个人玩，一个人是走O，一个人是走X，对吧，最后看谁是连在一起的，三个连成一排，可以是横的，可以是竖的，也可以是斜的，那么依照这个样子的话就可以走出来，它这样的一个状态树了。
    走出了这个状态树的话，你会发现当X走在这个地方，O走在这个地方的话，那么最后结局已经注定了，肯定X就赢了。那唯一一种可能就是走到这个分支的话，它可能是平局，最后走到这边是平局。其他的分支的话，走这里X赢了，走这里X也赢了，所以当它走了这两步的时候，已经判断至少X是不败的。
    也就是说你把整个状态树，都之前已经遍历过一次的话，这时候你基本上属于一种开天眼的状态，也就是开挂的状态，也就是一个不败的状态。
    所以关键就在于这个状态树的深度，你能不能搞定，以及你有没有什么很好的办法去剪枝，
    这就是三子棋的话，因为状态空间太简单了，所以你随便怎么写程序都可以搞定，也就是在最开始计算机搜索出来的时候，三子棋基本上就是必胜了，对人类对吧。
![](三子棋的状态树.png) 
#####围棋
在这里的话基于兴趣给大家拓展一下复杂度非常高的围棋：
这里你会发现我们回到这一盘棋（国际象棋）的它的棋谱，每个人走了37步，最后决出了。
![](围棋.png)
而在围棋这里你会发现，它最后走的步数是276步在这个地方，而且棋牌异常的大。所以的话它的状态空间的话，比国际象棋其实要大不少的。
它这里还有一个复杂度的来源，就是在于它每一层的分支的个数也非常的多。为什么？原因就是围棋的落子的话只要空地你都可以落上去，当然有一些是特别傻的位置，那么我们就直接剪枝点剪掉了。但是它可以落子的位置的话，其实是没有任何明显的限制的，而且可以落子的选择性非常多。
![](围棋的状态树.png)
正是因为这个原因的话，这里它的状态树来自于AlphaGo的文章，它的状态树是异常的复杂的，以至于开始用朴素简单的这种搜索没法有效地处理它所谓的状态树，找到最优的情况。
第一，它cover不了这么深的深度，另外的话分支太多了之后，直接又把它搜索空间给打爆掉了。因为这个原因的话，直到最近的几年才是由深度学习的一种方法，把它最后解决。
用深度学习的办法也是同样的思路，在这个状态树里面进行更加有效地评估，哪个分支更好以及更加及时地给剪枝出去，所以的话这时候你会发现虽然是用了深度学习，但是它的整个思想和之前是异曲同工的。
#####AlphaZero
https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/
见文章，略
#####棋类复杂度
https://en.wikipedia.org/wiki/Game_complexity
见链接，略
####回溯法：回溯=分治+试错
然后在这里的话再给大家为了内容的完整性，说一下回溯。
其实回溯本身的话没有和递归有太多本质上的区别。只不过它是采用一种试错的思想，尝试分布去解决一个问题。
这里其实它就是所谓的分治再加所谓的试错。
在分步解决问题过程中，当它尝试发现现有的分步答案，不能得到有效的结果的时候，它就会取消上一步或者上几步的计算，再通过其他的可能的分步解答，再次去尝试寻找问题的答案。
这个的话人类的话经常用，就是你在下象棋的时候就会想，我下这步行不行，再算对方可能干嘛，然后我再干嘛，可能你多算了三四步，最后发现我这步棋可能是个臭棋，然后再想那我不走这步了，我走其他步。
     你们在做问题决策的时候也会是这样，假设我今天想去玩的话会干嘛，然后我不玩的话，其他地方干嘛，就在脑子里面去不断地试，试完发现找一个最优解出来。
其实和人类很像，但是这里的话更加重要的是和人类的区别，或者是擅长点是什么？
这里的话我明确给大家之前指出过，
  人脑的一个问题，就是说它回溯的深度不够，因为它的短期记忆的话比较模糊，或者是说短期记忆不准，你经常回溯了一两层之后，你就不太记得这个字到底是不是我刚才走的这个位置怎么的。
  第二的话人类的话比较懒，或者是当你多回溯了几步之后特别累，这时候你就算了直接走了，就不再想了，对吧。
那么机器就擅长做，第一做重复的递归特别快，第二的话它的记忆肯定是无敌的，因为这个原因的话，所以机器在做回溯的话，特别是这种有重复性的回溯的话就是厉害的。
正是因为这个原因的话，我们才会搞出很多这种递归式的搜索以及所谓的这种回溯法。
那么回溯本身它定义在这个地方，定义没有什么巧的，关键是后面给大家讲具体题目的时候，大家可以再次理解一下整个回溯的思路。
#####定义
回溯法/试探法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当她通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，
 它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。
 回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
 - 找到一个可能存在的正确的答案；
 - 在尝试了所有可能的分步方法后宣告该问题没有答案。
 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
##########其实它本身的话就是一种递归和分治，只是它要不断地进行试错的环节。
###14.2 剪枝实战题目解析
#### 1. https://leetcode-cn.com/problems/climbing-stairs/  爬楼梯（非常重要，要掌握与coin change ii的区别和联系，并且掌握降维和泛化的思想）
所谓的爬楼梯问题和凑零钱问题？
爬楼梯问题怎么转换为Fibonacci的，以及爬楼梯问题可以转换为零钱兑换问题，也就是Coin Change那个问题，
你爬楼题可以每次爬一步两步，就类似于你有面值为1和面值为2的钱币，最后 要组成什么，一百块钱或者第n块钱，总值为n，你应该怎么走？
##### 零钱兑换II和爬楼梯问题到底有什么不同？ https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/
在LeetCode上有两道题目非常类似，分别是
- https://leetcode-cn.com/problems/climbing-stairs/ 70.爬楼梯：排列数
- https://leetcode-cn.com/problems/climbing-stairs/ 518. 零钱兑换 II：组合数
如果我们把每次可走步数/零钱面额限制为[1,2], 把楼梯高度/总金额限制为3. 那么这两道题目就可以抽象成"给定[1,2], 求组合成3的组合数和排列数"。

接下来引出本文的核心两段代码，虽然是Cpp写的，但是都是最基本的语法，对于可能看不懂的地方，我加了注释。
````
//那就是对于金额i, 我们选择硬币的方案。
class Solution1 {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int j = 1; j <= amount; j++){ //枚举金额
            for (int coin : coins){ //枚举硬币
                if (j < coin) continue; // coin不能大于amount
                dp[j] += dp[j-coin];
            }
        }
        return dp[amount];
    }
};

//必须选择第k个硬币时，凑成金额i的方案
class Solution2 {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int coin : coins){ //枚举硬币
            for (int j = 1; j <= amount; j++){ //枚举金额
                if (j < coin) continue; // coin不能大于amount
                dp[j] += dp[j-coin];
            }
        }
        return dp[amount];
    }
};

````
如果不仔细看，你会觉得这两个Solution似乎是一模一样的代码，但细心一点你会发现他们在嵌套循环上存在了差异。这个差异使得一个求解结果是排列数，一个求解结果是组合数。

因此在不看后面的分析之前，你能分辨出哪个Solution是得到排列，哪个Solution是得到组合吗？

在揭晓答案之前，让我们先分别用DP的方法解决爬楼梯和零钱兑换II的问题。每个解题步骤都按照DP三部曲，a.定义子问题，b. 定义状态数组，c. 定义状态转移方程。

######70. 爬楼梯
问题描述如下:

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

这道题目子问题是，problem(i) = sub(i-1) + sub(i-2), 即求解第i阶楼梯等于求解第i-1阶楼梯和第i-2阶楼梯之和。

状态数组是 DP[i], 状态转移方程是DP[i] = DP[i-1] = DP[i-2]

那么代码也就可以写出来了。
````
class Solution {
public:
    int climbStairs(int n) {
        int DP[n+1];
        memset(DP, 0, sizeof(DP));
        DP[0] = 1;
        DP[1] = 1;
        for (int i = 2; i <= n; i++){
            DP[i] = DP[i-1] + DP[i-2] ;
        }
        return DP[n];

    }
};
````
由于每次我们只关注DP[i-1]和DP[i-2]，所以代码中能把数组替换成2个变量，降低空间复杂度，可以认为是将一维数组降维成点。

如果我们把问题泛化，不再是固定的1，2，而是任意给定台阶数，例如1,2,5呢？

我们只需要修改我们的DP方程DP[i] = DP[i-1] + DP[i-2] + DP[i-5], 也就是DP[i] = DP[i] + DP[i-j] ,j =1,2,5

在原来的基础上，我们的代码可以做这样子修改
````
class Solution {
public:
    int climbStairs(int n) {
        int DP[n+1];
        memset(DP, 0, sizeof(DP));
        DP[0] = 1;
        int steps[2] = {1,2};
        for (int i = 1; i <= n; i++){
            for (int j = 0; j < 2; j++){
                int step = steps[j];
                if ( i < step ) continue;// 台阶少于跨越的步数
                DP[i] = DP[i] + DP[i-step];
            }
        }
        return DP[n];

    }
};
````
后续修改steps数组，就实现了原来问题的泛化。

那么这个代码是不是看起来很眼熟呢？我们能不能交换内外的循环呢？也就是下面的代码

````
for (int j = 0; j < 2; j++){
    int step = steps[j];
    for (int i = 1; i <= n; i++){
        if ( i < step ) continue;// 台阶少于跨越的步数
         DP[i] = DP[i] + DP[i-step];
    }
}
````
大家可以尝试思考下这个问题，嵌套循环是否能够调换，调换之后的DP方程的含义有没有改变？
######零钱兑换II
问题描述如下:
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

定义子问题: problem(i) = sum( problem(i-j) ), j =1,2,5. 含义为凑成总金额i的硬币组合数等于凑成总金额硬币i-1, i-2, i-5,...的子问题之和。

我们发现这个子问题定义居然和我们之前泛化的爬楼梯问题居然是一样的，那后面的状态数组和状态转移方程也是一样的，所以当前问题的代码可以在之前的泛化爬楼梯问题中进行修改而得。
````
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int j = 1; j <= amount; j++){ //枚举金额
            for (int i = 0; i < coins.size(): i++){ 
                int coin = coins[i]; //枚举硬币
                if (j < coin) continue; // coin不能大于amount
                dp[j] += dp[j-coin];
            }
        }
        return dp[amount];
    }
};
````
这就是我们之前的Solution1代码。

但是当你运行之后，却发现这个代码并不正确，得到的结果比预期的大。究其原因，该代码计算的结果是排列数，而不是组合数，也就是代码会把1,2和2,1当做两种情况。但更加根本的原因是我们子问题定义出现了错误。

正确的子问题定义应该是，problem(k,i) = problem(k-1, i) + problem(k, i-k)

即前k个硬币凑齐金额i的组合数等于前k-1个硬币凑齐金额i的组合数加上在原来i-k的基础上使用硬币的组合数。说的更加直白一点，那就是用前k的硬币凑齐金额i，要分为两种情况开率，一种是没有用前k-1个硬币就凑齐了，一种是前面已经凑到了i-k，现在就差第k个硬币了。

状态数组就是DP[k][i], 即前k个硬币凑齐金额i的组合数。

这里不再是一维数组，而是二维数组。第一个维度用于记录当前组合有没有用到硬币k，第二个维度记录现在凑的金额是多少？如果没有第一个维度信息，当我们凑到金额i的时候，我们不知道之前有没有用到硬币k。

因为这是个组合问题，我们不关心硬币使用的顺序，而是硬币有没有被用到。是否使用第k个硬币受到之前情况的影响。

状态转移方程如下

````
if 金额数大于硬币
    DP[k][i] = DP[k-1][i] + DP[k][i-k]
else
    DP[k][i] = DP[k-1][i]
````
因此正确代码如下:
````
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int K = coins.size() + 1;
        int I = amount + 1;
        int DP[K][I];
        //初始化数组
        for (int k = 0; k < K; k++){
            for (int i = 0; i < I; i++){
                DP[k][i] = 0;
            }
        }
        //初始化基本状态
        for (int k = 0; k < coins.size() + 1; k++){
            DP[k][0] = 1;
        }
        for (int k = 1; k <= coins.size() ; k++){
            for (int i = 1; i <= amount; i++){  
                if ( i >= coins[k-1]) {
                    DP[k][i] = DP[k][i-coins[k-1]] + DP[k-1][i]; 
                } else{
                    DP[k][i] = DP[k-1][k];
                }
            }
        }
        return DP[coins.size()][amount];
    }
};
````
我们初始化的数组大小为coins.size()+1* (amount+1), 这是因为第一列是硬币为0的基本情况。

此时，交换这里面的循环不会影响最终的结果。也就是
````
for (int i = 1; i <= amount; i++){  
    for (int k = 1; k <= coins.size() ; k++){ 
        if ( i >= coins[k-1]) {
            DP[k][i] = DP[k][i-coins[k-1]] + DP[k-1][i]; 
         } else{
             DP[k][i] = DP[k-1][k];
         }
     }
}
````
之前爬楼梯问题中，我们将一维数组降维成点。这里问题能不能也试着降低一个维度，只用一个数组进行表示呢？

这个时候，我们就需要重新定义我们的子问题了。

此时的子问题是，对于硬币从0到k，我们必须使用第k个硬币的时候，当前金额的组合数。

因此状态数组DP[i]表示的是对于第k个硬币能凑的组合数

状态转移方程如下
````
 DP[[i] = DP[i] + DP[i-k]
 ````
于是得到我们开头的第二个Solution。
````
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int dp[amount+1];
        memset(dp, 0, sizeof(dp)); //初始化数组为0
        dp[0] = 1;
        for (int coin : coins){ //枚举硬币
            for (int i = 1; i <= amount; i++){ //枚举金额
                if (i < coin) continue; // coin不能大于amount
                dp[i] += dp[i-coin];
            }
        }
        return dp[amount];
    }
};
````
好了，继续之前的问题，这里的内外循环能换吗？

显然不能，因为我们这里定义的子问题是，必须选择第k个硬币时，凑成金额i的方案。如果交换了，我们的子问题就变了，那就是对于金额i, 我们选择硬币的方案。

同样的，我们回答之前爬楼梯的留下的问题，原循环结构对应的子问题是，对于楼梯数i, 我们的爬楼梯方案。第二种循环结构则是，固定爬楼梯的顺序，我们爬楼梯的方案。也就是第一种循环下，对于楼梯3，你可以先2再1，或者先1再2，但是对于第二种循环

参考资料
https://leetcode-cn.com/problems/coin-change-2/solution/518-ling-qian-dui-huan-ii-you-hua-dong-tai-gui-hua/
背包问题9讲:https://raw.githubusercontent.com/tianyicui/pack/master/V2.pdf
labuladong的算法小抄: https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa

#### 2. https://leetcode-cn.com/problems/generate-parentheses/  括号生成
在这里的话，那么我希望大家就是自己回去一下，再练一遍这样的题目以及感受它所谓的剪枝的思想。
首先的话就是其中有一个办法的话，就是说你在这个地方把它当成6个格子2n个格子。
每个格子可以放左括号和右括号，这是我们之前让它写的办法。
那么在写的时候，如果你只是简单地生成的话，这个时候你会发现有很多最后是无效的括号。
那么在这里的话就进行了所谓的剪枝，
当时的剪枝的条件就是左括号始终都可以放，但是它的个数它的配额只有n个，右括号的配额也只有n个，右括号必须在前面有左括号的时候才能放，
用这样的一个条件，最后就剪枝成功了。

#####随堂练习：用DP来解决括号生成问题
#### 3. https://leetcode-cn.com/problems/n-queens/  N皇后
八皇后问题的代码，所谓的用columns和撇和捺在这里，这种方式来进行判重，大家一定要后来的话做各种搜索，一定要滚瓜烂熟。
几节课之前我们在讲的时候就说这里进行判重，而它的本质的思想是什么。其实就是剪枝。
只要是columns被占了，或者是撇被占了，或者是捺被占了之后，我们就马上进行剪枝。就说这个地方不能再填皇后了
不然的话我们的话就会在每一行都加，加了之后，最后再判断有没有皇后互相吃对方，那么所谓的用columns和不同的set来进行剪枝的这种方式的话，在这里的给大家回顾一下。
大家一定要把它弄得非常的熟悉
#### 4. https://leetcode-cn.com/problems/valid-sudoku/description/  有效的数独
官方题解: https://leetcode-cn.com/problems/valid-sudoku/solution/you-xiao-de-shu-du-by-leetcode/
代码本身的话，这个题目其实并不复杂。
关键就是考验你怎么做这个棋盘的表示，那么怎么做？
![](有效的数独.png)
棋盘的表示（box_index = (row / 3) * 3 + columns / 3）其实就是除以3然后再乘以3或者是模3之类的，就把左上角、中上角和右上角，3X3的格子给抽出来了，这就是来进行所谓的判重的问题。
好的，这也可以在这个地方，大家自己的话去模拟地写一下。
这个题目没有任何所谓的回溯或者剪枝，就是写循环进行判断，看这个行或者列，是否这个数字只出现一次。
大家一定要自己写一遍，自己练，主要是练你的基本功。
如果你的代码非常的长，或者你个人觉得非常的冗余的话，看一下别人怎么做的，看一下别人到底是怎么做的，把自己的代码写清晰。
````
class Solution {
   public boolean isValidSudoku(char[][] board) {
        if (board == null || board.length > 9 || board[0].length > 9 ) {
            return false;
        }

        return backTrace(board, 0, 0);
    }

    public boolean backTrace(char[][] board, int row, int col) {
        //如果col越界，那么重新指向下一行
        if (col == 9) {
            return backTrace(board,row+1,0);
        }
        //如果row越界，说明遍历完成，那么当前返回true
        if (row == 9) {
            return true;
        }

        //如果当前位置没有显示数字，直接跳向下一个位置
        if (board[row][col] == '.') {
            return backTrace(board,row,col+1);
        }
        // 这个位置数字已给出，需要试探，
        if (board[row][col] != '.') {
            //如果在当前位置上不成立直接返回false
            if (!isValid(board, row, col)) {
                return false;
            }
            //如果这个位置上成立。直接试探下一个位置
            return backTrace(board,row,col+1);
        }

        //如果全部遍历之后，没有false那么就返回true
        return true;
    }

    
    
    /**
    * 看当前位置是否有效，非常重要
    */
    private boolean isValid(char[][] board, int row, int col) {
        char ch = board[row][col];
        // 三个方向，任一方向，其它8个位置上的数和当前位置ch不能相同
        for (int k = 0; k < 9; k++) {
            // 同一行九个位置已出现 ch
            if (board[row][k] == ch) {
                if (k != col) {
                    return false;
                }
            }
            // 同一列九个位置中已出现 ch
            if (board[k][col] == ch){
                if (k != row) {
                    return false;
                }
            }

            //看其他8个位置是否出现ch
            // 同一个子数独九个位置中已出现 ch
            if (board[(row / 3) * 3 + k / 3][(col / 3) * 3 + k % 3] == ch){
                if ((row / 3) * 3 + k / 3 != row && (col / 3) * 3 + k % 3 != col) {
                    return false;
                }
            }
        }
        return true;
    }
}
````
#### 5. https://leetcode-cn.com/problems/sudoku-solver/#/description  解数独
https://leetcode-cn.com/problems/sudoku-solver/solution/jie-shu-du-by-leetcode-solution/
我们来看数独的真正在剪枝和搜索上面的运用就是这个题目。
#####讲解：
接下来就给大家讲解这个题目的话如何搜索以及如何剪枝，对不对。
这时候你会发现这个题目本身的话，其实和八皇后问题差不多，它每个格子和八皇后问题一样，每个格子可以填皇后，对不对，你要判断填了之后这个皇后是否位置合法。所谓的合法就是，皇后的话就是不和其他皇后发生攻击。
这里的话同理可得，每一个位置可以放123456789，关键就看是否合法。所谓的合法就是看横竖以及所在的3X3的块不会出现重复数字，对不对。那么怎么做？
我们就直接看题解里面这个图，我结合它画的这个图来讲。
1.蛮力法：蛮力法就不说了，就是狂写循环来判断就行了。但是最关键的话就是要干嘛，尽早地把不用的枝条给剪掉，所谓的剪枝越快越好。
2.递归+回溯
  那么我们来看这个棋盘，第一个空的格子。如果你是先扫第一行。然后第一行里面的每一个空位的话，这个是第一个考虑的。
  这时候的话在这里第一个考虑的时候，我们就会发现什么，第一个格子里面我们就可以拿123456789进去判断，在判断的时候，这时候我们就会发现什么，这个地方到底可不可以放。第一时间我们就检查它所在的行和列以及这个block能不能放，能放的话我们就继续看下一行，直到发现后面不行的话，我们再回过来把这个替换成2、替换成3（3的话直接就不行了）、替换成4，我们都去查找一下，这就是所谓我们的思想。
  其实这里和八皇后一样，我们需要三个set分别来记录行有没有重复的数字或者哪些数字已经占了，列哪些数字已经占了，以及3X3的块，哪些数字已经占了。就不断地这么就是递归和回溯下去即可
  这里有一个块的索引的话：box_index = (row / 3) * 3 + columns / 3。为什么是这个的话，大家看一下，通过这个方式的话，就012345678这么一个技术处理，大家一定要记得就和撇和捺那个差不多，一个是x+y x-y类似于。
  这里3X3block怎么弄，就是方块索引=(行/3)*3+列/3，就这么的话就会把九个block标成012345678，标下来了。然后就开始回溯即可。
  ![](数独的索引.png)
#####JAVA代码1：
  https://leetcode.com/problems/sudoku-solver/discuss/15752/Straight-Forward-Java-Solution-Using-Backtracking
````
public class Solution {
    public void solveSudoku(char[][] board) {
        if(board == null || board.length == 0)  //判断棋盘是否合法
            return;
        solve(board);  //合法的话调solve来进行解决
    }
    
    public boolean solve(char[][] board){
        for(int i = 0; i < board.length; i++){  
            for(int j = 0; j < board[0].length; j++){  //solve来进行解决的话就干嘛，遍历整个棋盘，这个就是做一个简单的二维数组的遍历。遍历整个棋盘
                if(board[i][j] == '.'){
                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9   //对于棋盘有空位的地方开始1到9去试图填这个格子里面去，对吧
                        if(isValid(board, i, j, c)){  //每次填了之后就来判断整个棋盘是否合法，这个函数本身它怎么实现我们再看，但这个函数其实就是判断整个棋盘是否合法，而这个函数的话就是上一个题目给大家说的。数独的合法验证问题的代码就可以拿过来用即可
                            board[i][j] = c; //Put c for this cell：如果合法的话就把格子上试着填上c就填进去了，
                            
                            if(solve(board)) //填进去了之后，然后再递归调用solve，再递归调用。各位这个solve就直接调上来了。因为它已经填了，所以就递归调用solve。
                                return true; //If it's the solution return true ：如果这个solve能解决的话就，说明整个棋盘已经解决了，return true就行了
                            else
                                board[i][j] = '.'; //Otherwise go back：不然的话要把这个状态给恢复，这里的else可以不用写，而把board[i][j]='.'写到这上面来即可
                        }
                    }
                    
                    return false;  //如果实在什么都不行的话，就return false就行了
                }
            }
        }
        return true;  //如果整个棋盘也可以搞完的话，最后也是return true在这个位置
    }
    
    private boolean isValid(char[][] board, int row, int col, char c){  //那我们再看棋盘怎么判断它是否合法非法，这就是上一个题目的代码。其实就是写一个循环，看整个它列行还有block里面是否没有重复的元素，对吧，没有重复的c，用这个条件来判断它到底是否是合法的。只要任何一个地方碰到重复了，就说明非法，不然的话就是合法的。
        for(int i = 0; i < 9; i++) {
            if(board[i][col] != '.' && board[i][col] == c) return false; //check row
            if(board[row][i] != '.' && board[row][i] == c) return false; //check column
            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && 
board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block
        }
        return true;
    }
}

这就是它这个代码主要的主干：整个DFS、你也可以认为是回溯和它的整个判重的逻辑就是这样的。大家一定要自己体会一下。
我想大家可能自己试着写过，一想这个代码可能巨复杂无比。那么看了这个之后，马上是不是觉得自己蠢蠢欲动，自己也想动手撸一把，那自己现在就开始写起来，写起来这样的代码，自己来看一下自己是不是写的代码就很长，然后如何简化，如何把自己的代码驾驭的能力提高。就开始自己动手。
````
#####JAVA代码2：
https://leetcode.com/problems/sudoku-solver/discuss/15911/Less-than-30-line-clean-java-solution-using-DFS
````
public class Solution {
    public void solveSudoku(char[][] board) {
        dfs(board,0);//入口在这个地方
        //d从0开始
    }
    private boolean dfs(char[][] board, int d) {
    //进来之后，这时候你会发现多了一个参数，叫做所谓的第二个0，就是叫d。前面的话就是传进来board没什么好说的
    //这里多了一个d，它是要干嘛的：解释一下，之前不是说这有个棋盘吗，这时候你会发现它是9*9的，所以它总共有9*9=81个格子
    //9*9=81格子，每个格子它可以填1到9，你就可以认为它递归总共有多少：81层。这里是第一层第二层第三层第四次呢个第五层，一直走下去，走到第九九八十一层的时候，就说明它全部格子都扫完了
    //所以它在这里就搞了一个所谓的level，它的层级
    //也就是说把格子整个编号012345678然后910这么一直编到81，就这么一个过程。这就是所谓的d
        if (d==81) return true; //found solution：当level==81的时候，这就是所谓的递归终止条件。
        int i=d/9, j=d%9; //从每次得到d之后，我们就可以算它的横坐标和纵坐标是多少：横坐标=d/9, 纵坐标=d%9。这么一个整除和膜的关系，在后面判断也同样用到，判断block的时候int r=i/3*3+k/3，int c=j/3*3+k%3这个一个关系
        if (board[i][j]!='.') return dfs(board,d+1);//prefill number skip：如果当前坐标board的值，假设它不是点说明什么，如果它这时候不是点的话。就说明这个格子已经被占了，已经有数字在里面了。如果已经有数字在里面就直接下一层就行了。当前层就不用考虑，直接下一层就行
                                                    //同时还要注意，这上面在这里的话，不用就是恢复递归的状态了
        //关键就是如果这一层是点的话，就要干嘛
        boolean[] flag=new boolean[10]; 
        validate(board,i,j,flag); //开始validate board i,j，用flag进去validate，同时它会更新flag里面的值，用flag进去validate，同时它会更新flag里面的值，
        for (int k=1; k<=9; k++) {//如果validate通过了之后，我们就把这个flag存起来之后，
            if (flag[k]) { 
                board[i][j]=(char)('0'+k); //接下来它就尝试在board i,j里面，和上一个代码类似，在board i,j里面填上1到9所有的值，1到9所有的值填上之后再继续dfs,
                if (dfs(board,d+1)) return true;  //这个时候同样也是把d+1放进去，就相当于下钻到新的一层去，所以是d+1                              
            }
        }
        board[i][j]='.'; //if can not solve, in the wrong path, change back to '.' and out  ：但是因为我们在这里validate之后进行了这样一个操作（ board[i][j]=(char)('0'+k)），所以在这里的话，我们要把board[i][j]='.'，这样的话才可以继续回溯起来
        return false; //这个代码就在这里结束
    }
    private void validate(char[][] board, int i, int j, boolean[] flag) {//用flag进去validate，同时它会更新flag里面的值，flag里面的值就是来存所谓的1到9是否有重复的这样一个过程
        Arrays.fill(flag,true);
        for (int k=0; k<9; k++) {
            if (board[i][k]!='.') flag[board[i][k]-'0']=false;
            if (board[k][j]!='.') flag[board[k][j]-'0']=false;
            int r=i/3*3+k/3;
            int c=j/3*3+k%3;
            if (board[r][c]!='.') flag[board[r][c]-'0']=false;
        }
    }
}
```` 
#####python代码：见优秀题解之Python https://leetcode-cn.com/problems/sudoku-solver/solution/pythonsethui-su-chao-guo-95-by-mai-mai-mai-mai-zi/
````
    def solveSudoku(self, board: List[List[str]]) -> None:
        row = [set(range(1, 10)) for _ in range(9)]  # 行剩余可用数字
        col = [set(range(1, 10)) for _ in range(9)]  # 列剩余可用数字
        block = [set(range(1, 10)) for _ in range(9)]  # 块剩余可用数字

        empty = []  # 收集需填数位置
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':  # 更新可用数字
                    val = int(board[i][j])
                    row[i].remove(val)
                    col[j].remove(val)
                    block[(i // 3)*3 + j // 3].remove(val)
                else:
                    empty.append((i, j))

        def backtrack(iter=0):
            if iter == len(empty):  # 处理完empty代表找到了答案
                return True
            i, j = empty[iter]
            b = (i // 3)*3 + j // 3
            for val in row[i] & col[j] & block[b]:
                row[i].remove(val)
                col[j].remove(val)
                block[b].remove(val)
                board[i][j] = str(val)
                if backtrack(iter+1):
                    return True
                row[i].add(val)  # 回溯
                col[j].add(val)
                block[b].add(val)
            return False
        backtrack()
````
######启发式搜索的伏笔
在这里的话，既然我已经在这里把这个代码拎出来给大家专门讲了之后，我给大家埋下一个伏笔。
就是说这时候你会发现它有empty的各种格子，对不对，同时的话按照人脑的进行处理，
人脑的思考方式是什么，就是说你先找的话就看哪个格子可选的数较少，越是可选数较少的格子，我们就可能先填或者先回溯，因为你先试这个格子和先试这个格子或者是先试这个格子它没有任何的区别。
你随便可以先试哪个都行，那么我们应该尽量干嘛，尽量从格子候选项少的格子，就是这个格子要是已经确定要填一个数，那就直接填上就行了。
这样来开始搜索，也就是会导致后面的更高级的搜索叫启发式搜索。
启发式搜索的话就按照优先级来，这里的优先级就是这个格子里面可填的数越少，那就越先搜对吧，越先搜越加上了之后，就会影响其他这些空格的话，可填的数也进一步变少，这样的话就更加地优化了。
所以这里给大家埋一个伏笔，通过这样的预处理，我们就可以得到所有的空格数。
同时进一步在下一章我们会告诉大家，在这个格子里面我们可以进一步预先算出来，然后它可以填的数是哪些，那么这个格子能够预先填的数越少的格子，我们就越先进行所谓的处理，这样的话我们的搜索就不再是深度优先，也不再是广度优先了，就变成一种所谓的优先级优先，这里的优先级就代表你可填的候选数越少，那么你就越优先。
这就是给后面的启发式搜索或者是A* search打下了一个伏笔在这里。

#####优秀题解：
  python 
     https://leetcode-cn.com/problems/sudoku-solver/solution/pythonsethui-su-chao-guo-95-by-mai-mai-mai-mai-zi/
  java 
     https://leetcode-cn.com/problems/sudoku-solver/solution/jie-shu-du-by-leetcode-solution/



###14.3 双向BFS的实现、特性和题解
我们现在继续来看双向BFS，之前说过了在朴素的搜索里面优化的话主要是两个方向：1.尽量让它去重复以及尽早地剪枝，2.在搜索的方向上面进行一些加强
我们先讲之前讲过的BFS的话，全部都是单向搜索。这里的话给大家讲一个新的思路，就是所谓的双向BFS，这个在搜索中，其实在高级的搜索中用得较多，而且代码的话并不难。
思路是什么的话，首先给大家说一下：
#### BFS：单向搜索
我们来看这个图，这是一个简单的双向连通图，从A一直连最后要连到L去，请问有最短可以走多少步？
怎么从A计算到L去吗？那就从A做一个广度优先搜索BFS，广度优先搜索搜索出去之后先到达邻接的两个点，一个是C、一个是B，把邻接的两个点C和B加到queue里面，
然后再依次处理queue里面接下来的元素，先处理C，C处理完了之后，它没有剩下的结点，再处理B，B的话再扩散出D和E，
同理，G的话扩散出IJ，再扩散出L，
这就是真个BFS像水波纹一样，向外面一层一层地扩散，当它第一次扩散到L的话，扩散的步数就是它的最少步数。
那么我们将前面这个图，按照它扩散出来的层次的关系，它每一个颜色指的是扩散的步数，A的话是起始点，蓝色的话BC一次扩散，黄色二次扩散，灰色三次扩散，橙色四次扩散。
![](双向连通图BFS.png)
那就把它直接放到这么一个分好层，就是把这个图稍微变形一下，重新挪动一下位置，让它看起来更加得有层次感。
那么第1层、第2层、第3层、第4层、第5层、第6层，然后就走过来，这就是BFS。
![](双向连通图BFS搜索层级.png)
#### Two-ended BFS / 双向BFS
那么双向BFS是什么样子呢？也很容易，与其从A开始一步一步扩散，我们直接这样做吧，既从A（起点）向右边一层一层扩散，也从L（终点）向左边一层一层一层地扩散。
所以这边第1层、第2层、第3层，同理对于L向左进行扩散，也是第1层、第2层、第3层、第4层，上面这个数字的话，就只针对A，对L的话就把它反过来：第1层、第2层、第3层，当它扩散的两层的结点有重合的时候，第1次重合的地方就是A和L两者之间的最短路径，把这边扩散的步数再加上右边扩散的步数，最后的话和就是最后的总的步数。
这就类似于我们要火车高铁要经过高山的时候，会打一个山洞，那么你要穿这个山的话，你从A点开始打洞，一直打到B点，那么更好的方式就是A和B同时往中间打就行了，最后在中间相遇的时候，那么更快，就是这么一个思路。
![](双向连通图双向BFS.png)
#### 作业：总结双向BFS模板

#### 实战题目
##### 1. https://leetcode-cn.com/problems/word-ladder/ 单词接龙 （非常高频题，记得多写：word ladder的话在硅谷的公司的话，不知道被考了多少次了）
如果各位用BFS应该怎么写？所以如果各位面试碰到这个题目的话，首先和面试官把这个题目的各种corner cases（边界条件），所谓的corner cases就是各种边界条件，各种可能比较细节的问题和面试官给讨论清楚。
讨论清楚了之后，然后要做的一件事情就是什么，把所有可能的想法都给他说好了。
1. BFS:从beginWord开始向外扩散，每次扩散这个字符扩散到不同的字符，然后看这个字符是不是在这个单词列表里面。是的话，就把这些单词作为候选的加到queue里面去
2. DFS:DFS反复去找，但是的话DFS要做比较强的剪枝觉得。大家可以去试一下写DFS，就是要把所有的剪枝都列出来。因为这个单词的列表是有限的，所以这里做DFS的话的复杂度，其实没有想象那么高。
3. Two-ended BFS/双向BFS:前面两者大家有兴趣的话可以自己写一下，我在这里要求大家BFS自己现在就动手，先写一下
java:
````
/*
双向bfs并不是从两端同时bfs, 实际上是这次从begin进行bfs, 下次从end进行bfs, 像这样循环操作
*/
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        //endWord也是transformed word, 所以必须存在于wordList中, 否则返回0, 表示无法从beginWord变成endWord
        if(!wordList.contains(endWord))
            return 0;
        //
        int n = beginWord.length();
        //key是通用状态; value是拥有该通用状态的词
        HashMap<String,ArrayList<String>>all_commons = new HashMap<>();
        //记录wordList中所有元素对应的所有通用状态
        wordList.forEach(
                word->{
                    for(int i=0; i<n; i++){
                        String common = word.substring(0,i)+"*"+word.substring(i+1);
                        if(!all_commons.containsKey(common))
                            all_commons.put(common, new ArrayList<String>());
                        all_commons.get(common).add(word);
                    }
                }
        );
        //使用HashSet实现宽度优先遍历bfs
        HashSet<String> begin = new HashSet<>();
        HashSet<String> end = new HashSet<>();
        begin.add(beginWord);
        end.add(endWord);
        //记录访问过的节点
        HashSet<String> visited = new HashSet<>();
        //细节: 返回值的初始化, 由于beginWord!=endWord, 所以至少需要一步变化
        int len = 1;
        while(!begin.isEmpty() && !end.isEmpty()){
            //核心:控制当前循环从哪个方向进行bfs; 让begin指向size更小的集合, 这样就不会一直从一个方向bfs了
            if(begin.size()>end.size()){
                HashSet<String> tmp = begin;
                begin = end;
                end = tmp;
            }
            //记录遍历begin时每个元素的邻居, 也就是cur的邻居
            HashSet<String> neighbor = new HashSet<>();
            for(String cur : begin){
                //遍历cur的邻居
                for(int i=0; i<n; i++){
                    String tmp = cur.substring(0,i)+"*"+cur.substring(i+1);
                    //有了all_commons哈希表,就不用每个位置都遍历'a'~'z'了
                    //细节:如果cur是beginWord的话, all_commons没有统计beginWord的通用状态, 所以all_commons.get(tmp)可能返回null, 所以要提前检查一下
                    if(!all_commons.containsKey(tmp))
                        continue;
                    for(String str : all_commons.get(tmp)){
                        if(end.contains(str))
                            return len+1;
                        if(!visited.contains(str)){
                            visited.add(str);
                            //记录cur的邻居
                            neighbor.add(str);
                        }
                    }
                }
            }
            //处理完begin中的元素后, 让begin指向begin中的元素的邻居
            begin = neighbor;
            //路径长度++
            len++;
        }
        //执行到这里说明双向bfs没有相遇, 也就是没有找到从beginWord到endWord的路径
        return 0;
    }
}
````
python:略

##### 2. https://leetcode-cn.com/problems/word-ladder-ii/ 单词接龙ii （非常高频题，记得多写）
没有讲解

##### 3. https://leetcode-cn.com/problems/minimum-genetic-mutation/ 最小基因变化
各位自己去做，你转换成这个图形的话，就是用树形结合的话，你进行转换，你会发现这个题目的话和那个题目（word-ladder）其实就是一样的。 这个题解里面没有画图的，但其实的话和那个题目就是一样的。
各位的话就类似于先写一个BFS对吧，然后再试着用刚才讲的双向BFS来写一下基因的问题。
这个题目和那个题目（word-ladder）基本上就是一个意思。
###14.4 启发式搜索(Heuristic Search(A*))的实现、特性和题解
现在我们来看高级搜索的最后一部分，叫做启发式搜索。
这里的启发式的话来自英文单词heuristic。为什么叫启发式，中文其实没有人这么讲的。
这里的heuristic的话，你可以认为是智能搜索，或者是根据某一项条件，我们来不断地优化搜索的方向，这个叫heuristic。也就是说你一边搜索，一边有所谓的思考在里面，你可以也叫作思考型搜索，类似于这样。
但是，我之前给大家概述里面已经讲过了，本质上其实就是通过优先级不断地去找、要找的点，先用优先级高的拿出来搜索即可。

A* （A-Star)算法是一种静态路网中求解最短路最有效的直接搜索方法。
注意是最有效的直接搜索算法。之后涌现了很多预处理算法（ALT，CH，HL等等），在线查询效率是A*算法的数千甚至上万倍。
公式表示为： f(n)=g(n)+h(n),
其中 f(n) 是从初始点经由节点n到目标点的估价函数，
g(n) 是在状态空间中从初始节点到n节点的实际代价，
h(n) 是从n到目标节点最佳路径的估计代价。
保证找到最短路径（最优解的）条件，关键在于估价函数f(n)的选取：
估价值h(n)<= n到目标节点的距离实际值，这种情况下，搜索的点数多，搜索范围大，效率低。但能得到最优解。并且如果h(n)=d(n)，即距离估计h(n)等于最短距离，那么搜索将严格沿着最短路径进行， 此时的搜索效率是最高的。
如果 估价值>实际值,搜索的点数少，搜索范围小，效率高，但不能保证得到最优解。
####代码
那么我们现在来过一遍代码。本身A*这个算法或者叫启发型搜索的话，就是基于BFS的。
#####基于BFS代码
BFS代码就是这个样子，之前给大家埋过一个伏笔。
与其在这个地方，while queue里面，在queue每次都pop一个最近的元素，与其做这件事情对吧。
还不如干嘛，在这里pop node的时候，我们再考虑一下这个地方，在pop node的时候，我们可不可以在这里多加一些智能的元素在里面，这里就是说引入了不再是用queue了，queue只是简单的先入先出太傻了。
在这里用优先队列，
``````
def BFS(graph, start, end):
   
   queue = []
   queue.append([start])
   visited.add(start)
   
   while queue:
      node = queue.pop()  #can we add more intelligence here ?
      visited.add(node)
      
      process(node)
      node = generate_related_nodes(node)
      queue.push(nodes)
``````
#####A* search 代码模板
这就是A*的模板了，在这里的话我们就不再用queue，我们叫做PQ，PQ就是priority queue的意思，就priority queue的话把它简写成PQ了
一开始把start放在PQ里面，visited也要放进去，
只要PQ不为空的时候，
每次从PQ里面pop出来优先级最高的结点，然后下面再进行相应地扩散出去，
这下面代码就是正常的BFS代码或者是DFS其实也是这样的代码，都是一样的
所以关键就是PQ pop在这里，我们就在这个地方，这就不是问号了，其实就是用这句话我们就加了一定的智能在里面了。
那么有些同学可能就自然而然会问这个问题，行。你用priority queue感觉用得不错，关键是优先级要怎么来定，对吧。
那么优先级要怎么来定的话，就是看这个问题，它具体怎样让你更优了，那么这个启发式函数也就是优先级定义函数或者叫做估价函数，
就是各位在进行A*或者叫启发式搜索的时候，你人要按照你自己的理解把这个估价函数给写出来。
````
# Python
def AstarSearch(graph, start, end):
	pq = collections.priority_queue() # 优先级 —> 估价函数	
	    # 那么有些同学可能就自然而然会问这个问题，行。你用priority queue感觉用得不错，关键是优先级要怎么来定，对吧。
        #  那么优先级要怎么来定的话，就是看这个问题，它具体怎样让你更优了，那么这个启发式函数也就是优先级定义函数或者叫做估价函数，
        #  就是各位在进行A*或者叫启发式搜索的时候，你人要按照你自己的理解把这个估价函数给写出来。
	
	pq.append([start]) 	 #一开始把start放在PQ里面，
	visited.add(start)	 #visited也要放进去,
	while pq:  #只要PQ不为空的时候，
	 	node = pq.pop() # add more intelligence here：每次从PQ里面pop出来优先级最高的结点，然后下面再进行相应地扩散出去
	                    # 所以关键就是PQ pop在这里，我们就在这个地方，这就不是问号了，其实就是用这句话我们就加了一定的智能在里面了。
	
		   #这下面代码就是正常的BFS代码或者是DFS其实也是这样的代码，都是一样的
		visited.add(node)		
			
		process(node) 		
		nodes = generate_related_nodes(node)    
	unvisited = [node for node in nodes if node not in visited]		
	    pq.push(unvisited)
````

#####估价函数
那么在这里的话正是因为启发式搜索的话，关键就在于估价函数或者是叫做优先级函数本身要怎么找，那么在这里的话这一页就专门来讲这个启发式函数。

启发式函数：一般把它认为是h(n)，h的话就是之前那个单词heuristic对吧，它用来评价哪些结点最有希望的是一个我们要找的结点，
           那么优先级最高的话，我们就最先去找就行了，到了最后你会发现它会把所有可能的结点，其实都会找一遍，只不过它找的顺序的话是优先级更高的结点。
           那么h(n)会返回一个我们假设非负实数好了，就可以认为是从结点n的目标地址的估计的成本类似于这样。
           （这个话本身的话是比较晦涩的，你就认为是这个值越大的话，说明这个点越优秀，可能会导致最后的结果。
           你怎么知道这个点，或者是你怎么知道哪些值会导致最后的结果，这后面的话就通过习题，我来具体给大家讲解。
           大家看这个题目例子就一下子可以体会到了。）

启发式函数是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居节点会导向一个目标。
####实战题目
#####1. https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/  二进制矩阵中的最短路径
1. dp
2. BFS ：经典的BFS代码
3. A* search
######Example
假设棋盘是这么一个样子，1全部都是障碍物
````
[
	[0,0,0,1,0,0,1,0],
	[0,0,0,0,0,0,0,0],
	[1,0,0,1,1,0,1,0],
	[0,1,1,1,0,0,0,0],
	[0,0,0,0,0,1,1,1],
	[1,0,1,0,0,0,0,0],
	[1,1,0,0,0,1,0,0],
	[0,0,0,0,0,1,0,0]
]
````
白色就是空地，绿色就是走过的足迹，黑色的话是障碍物就是1，那么从这里走到左边去，
我们人肉眼来看的话，就是感觉从这里开始走，先要从右下角直奔右下角走，走到这里的话发现都是石头挡了，那就往这边绕一圈之后，然后直下。或者是从这里绕上来绕一圈之后，直接下到右下角去。
- A*
那么用A*的话，当它在扩散的时候，就会根据估价函数，估价函数指的是这个点到这个点的坐标距离，坐标距离怎么算：就是横坐标差的绝对值加上纵坐标差的绝对值，那么你会发现它的扩散的时候，就尽量会找那些离右下角近的这一点，继续扩散出去，基本上的话我们会发现它会找到一个比较优的解。
第一次找过来，且它把这些边边角角一看比这些这个点要远的这些点就给筛掉了，后面再去找去了，它就不用去访问了，但是它也会把它放到优先队列里面去。
假设这个路都没有的话，它还会继续从这边找，只不过的话如果你中间的话，可以事先找到这个点的话，那就不需要了。
A*整个算法，如果用A*的话，你看它访问的足迹的话，就只在这些绿色的区域，你会发现这个足迹的话是它会保持在和右下角这个点尽量接近的一个位置。
- BFS
如果是整个BFS扩散的话，BFS扩散的话，按照BFS整个算法的逻辑性，也就是它的傻扩散的话，一开始q里面只有这个元素，只有左上角元素，
那么第一层会扩散出这一条、第二层就会扩散出全部这一条、也包括这个点、第二层会扩散出这么多、第三层再往外扩散、第四层再往外面扩散、第五层再往外面扩散，这么下来每次画一个斜对角线对吧画过来，
最后你会发现要走到这个终点的话，它会把所有的这些点其实都扩散一遍，而且它每次扩散就向外走一步，那么就是对角线一步一步这么走过来。
- 结论
由此可见，正是因为A*带有一定的启发式效果，也就是说思考型，它带来一定的思考性，所以在选择这个路径的话更优或者说更加的智能。
所以从这里看BFS给人的感觉就是比较傻瓜式的搜索或者叫暴力搜索，从图来看就是蠢萌蠢萌的，它就会直接像老牛耕田一样，老老实实地一遍一遍把整个图全部都扫完了之后，发现刚好到了右下角这个点是这么一个过程。
###### python Implementation
We perform an A* search to find the shortest path, then return it's length, if there is one. Note: I chose to deal with the special case, that the starting cell is a blocking cell, here rather than complicate the search implementation.
````
class Solution:
    def shortestPathBinaryMatrix(self, grid):
        shortest_path = a_star_graph_search(
            start              = (0, 0),   //开始结点
            goal_function      = get_goal_function(grid),  //最后的目标是什么，找右下的点
            successor_function = get_successor_function(grid), //下一个优先来取的东西
            heuristic          = get_heuristic(grid)  //估价函数到底是怎么样的
        )  //主力函数就是做这么一个事情，看这个即可（定制化）
        if shortest_path is None or grid[0][0] == 1:
            return -1
        else:
            return len(shortest_path)
````
###### A* search function
This implementation is somewhat general and will work for other constant-cost search problems, as long as you provide a suitable goal function, successor function, and heuristic.
````
def a_star_graph_search(
            start,
            goal_function,
            successor_function,
            heuristic
	):
    visited = set()
    came_from = dict()
    distance = {start: 0}
    frontier = PriorityQueue()  #首先这里不再是用q，而是用PQ
    frontier.add(start)  #还是一开始把start放进去
    while frontier: #只要PQ不为空的话，就继续
        node = frontier.pop() #这里每次把头结点给取出来
        if node in visited:  #头结点取出来之后判重，就是没有被访问过
            continue
        if goal_function(node):  #同时把goal拿出来之后
            return reconstruct_path(came_from, start, node)  #如果走到了最后一个结点，把路径长度返回
        visited.add(node)
        for successor in successor_function(node):  #不然的话就是继续搜索,继继续搜索的话就是开始扩散结点，从当前node怎么扩散，它的successor就是八连通图
            frontier.add(
                successor,
                priority = distance[node] + 1 + heuristic(successor)  #所以这个位置就是做了扩散之后，它就算出新的priority，得到了这个点就叫successor，它就把successor的重新的优先级通过heuristic method 给它算出来了，按照优先级加到了优先级队列里面去，所以它的优先级就是这么来定的。
                                                                      #也就是当前的distance再加1再加successor和终点之间的距离，叫做heuristic（比较他们的坐标差，就是这个坐标和右下角/目标点那个坐标之间的距离）
            )
            if (successor not in distance
                or distance[node] + 1 < distance[successor]):
                distance[successor] = distance[node] + 1
                came_from[successor] = node   #如果successor不在distance里面，或者要做的一件事情，就是把distance successor进行一轮更新，也就是这个时候它distance会更远了
                                              #这里的话你可以不做也行，你每次就是硬算，但是这里的话做了的话就是相当于可以加速或者是缓存一下
    return None

def reconstruct_path(came_from, start, end):
    """
    >>> came_from = {'b': 'a', 'c': 'a', 'd': 'c', 'e': 'd', 'f': 'd'}
    >>> reconstruct_path(came_from, 'a', 'e')
    ['a', 'c', 'd', 'e']
    """
    reverse_path = [end]
    while end != start:
        end = came_from[end]
        reverse_path.append(end)
    return list(reversed(reverse_path))
````
######Goal function
We need a function to check whether we have reached the goal cell:
````
def get_goal_function(grid):
    """
    >>> f = get_goal_function([[0, 0], [0, 0]])
    >>> f((0, 0))
    False
    >>> f((0, 1))
    False
    >>> f((1, 1))
    True
    """
    M = len(grid)
    N = len(grid[0])
    def is_bottom_right(cell):
        return cell == (M-1, N-1)  //判断当前这个点是不是走到最后了
    return is_bottom_right
````
######Successor function
We also need a function to find the cells adjacent to the current cell:
````
def get_successor_function(grid):
    """
    >>> f = get_successor_function([[0, 0, 0], [0, 1, 0], [1, 0, 0]])
    >>> sorted(f((1, 2)))
    [(0, 1), (0, 2), (2, 1), (2, 2)]
    >>> sorted(f((2, 1)))
    [(1, 0), (1, 2), (2, 2)]
    """
    def get_clear_adjacent_cells(cell):
        i, j = cell
        return (
            (i + a, j + b)
            for a in (-1, 0, 1)
            for b in (-1, 0, 1)
            if a != 0 or b != 0
            if 0 <= i + a < len(grid)
            if 0 <= j + b < len(grid[0])
            if grid[i + a][j + b] == 0
        )
    return get_clear_adjacent_cells
````
######Heuristic
The chosen heuristic is simply the distance to the goal in a clear grid of the same size. This turns out to be the maximum of the x-distance and y-distance from the goal. This heuristic is admissible and consistent.
````
def get_heuristic(grid): 
    """
    >>> f = get_heuristic([[0, 0], [0, 0]])
    >>> f((0, 0))
    1
    >>> f((0, 1))
    1
    >>> f((1, 1))
    0
    """
    M, N = len(grid), len(grid[0])
    (a, b) = goal_cell = (M - 1, N - 1)
    def get_clear_path_distance_from_goal(cell):
        (i, j) = cell
        return max(abs(a - i), abs(b - j))  #heuristic的话做的一件事情就是算传进来的grid和它当前的点距离goal右下角点它之间的距离
                                            #怎么算？就是横坐标的差的绝对值，加上纵坐标差的绝对值，这里它不是加的关系，它这里是换了另外一个是max的关系，那个代码会更好一点
    return get_clear_path_distance_from_goal
````
######Priority queue
The Python standard library provides a heap data structure, but not a priority-queue, so we need to implement one ourselves.
````
from heapq import heappush, heappop

class PriorityQueue:
    
    def __init__(self, iterable=[]):
        self.heap = []
        for value in iterable:
            heappush(self.heap, (0, value))
    
    def add(self, value, priority=0):
        heappush(self.heap, (priority, value))
    
    def pop(self):
        priority, value = heappop(self.heap)
        return value
    
    def __len__(self):
        return len(self.heap)
````

  估价函数: h(current_point) = dist(current_point,destination_point)
  这个讲完了之后，我给大家讲一个就是在一个二维矩阵里面，估价函数应该怎么弄：
  判断状态的相似性或者在二维的矩阵里面的这个图它之间的距离的相似性总共用的一个办法： https://dataaspirant.com/five-most-popular-similarity-measures-implementation-in-python/
  Manhattan distance = |x1-x2| + |y1-y2|
  Hamming distance = sum(el1 != el2 for el1, el2 in zip(s1, s2))  //python3 汉明距离就是两个字符串之间对应的位置不同的个数
###### java Implementation
````
class Solution {
    
    public int shortestPathBinaryMatrix(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {//grid合法性校验
            return -1;
        }
        if (grid[0][0]==1){//起点为障碍物即1，返回-1
            return -1;
        }
        int[] dx=new int[]{-1,0,1,0,-1,1,1,-1};
        int[] dy=new int[]{0,1,0,-1,1,-1,1,-1};  //八连通
        int M = grid.length-1;
        int N = grid[0].length-1;
        if(grid[M][N]==1) return -1; //终点为障碍物即1，返回-1
        int[] start = new int[]{0,0,grid[0][0] = 1};
        Queue<int[]> q  = new PriorityQueue<int[]>(new Comparator<int[]>(){  //优先级队列
            public int compare(int[] i1,int[] i2){
                return Math.max(M - i1[0], N - i1[1])+i1[2] - i2[2]-Math.max(M - i2[0], N - i2[1]);  //先遍历步数+距离较小的点
            }
        });
        q.offer(start);
        while(!q.isEmpty()){  //A* search 
            int[] cell = q.poll();
            int step = grid[cell[0]][cell[1]];
            if(cell[0]==M && cell[1]==N) return step;
            for(int k=0;k<8;k++){  //八连通扩散
                int y = cell[0]+dy[k];
                int x = cell[1]+dx[k];
                if(y <0 || y>M|| x<0||x>N) continue;
                if (grid[y][x] != 0 && grid[y][x] <= step + 1) continue;
                int[] next = new int[]{y,x,grid[y][x]=step+1};
                q.offer(next);
            }
        }
        return -1;
    }
}
````

#####2. https://leetcode-cn.com/problems/sliding-puzzle/  滑动谜题
这个题目的话指的是什么呢？指的是一个2X3的板，它有数字01234这种，最后的话你可以滑动中间0，滑动中间0的话，最后的话让状态从任何一个其他的状态就是变为123450这个状态（123450这6个元素组成的数组的状态树中由任何一个状态变为123450这个状态）。
它这个题目的话没有讲清楚，我个人觉得这个题目的话写得非常不好，在这里的话更好的话是给大家看一个板子的作图，那我们就直接看这个板子。
所谓的sliding puzzle叫滑动谜题，其实一个经典的问题，名字叫做8 puzzle。源自于小时候大家都玩过的一个游戏，这个游戏的话就给你一个3X3这样的板子，中间有一块是空的，中间这一块是空的，你就认为中间这一块是0就好了，你可以不断地上下左右移动这些板子，最后让板子要形成一种所谓的胜利的状态，就是12345678，最后空在这个地方。
小时候我想大家都玩过那种游戏，给你这么一块3X3的，有些时候是4X4的，有些时候5X5的或者5X6的都无所谓，mXn的好就行了，中间有块空的。
这个图案的话是一个圣斗士星矢或者是一个卡通人物或者是一个风景照，让你挪最后挪出来的话，风景照或者卡通人物是成型的。
![](8puzzles.jpg)
我们看这个图，那么其实就是我们这个题目就没有这么fancy各位。每个方块标了一个数字，这个数字最后让你挪，挪成有序的12345678，最后这里是空的。
这个问题因为有八个格子，所以叫做8 puzzle。但其实可以是任何维度的，这里的话是2X3的更加的容易一点。
这个弄好了之后，你会发现这个怎么做？123405，格子一画画出来，大家可以自己画一下，就只剩5和0没有归位，没有归成这样的位置，交换5和0，其实就是这样子。
我们再看一下这样的一个形式123540，要做的可能就复杂很多了，这种形式就是没有办法了。

状态树是什么样子，状态树的话也比较容易，就是把棋盘扩散出不同的棋盘，你每次就移0的位置嘛。

接下来我们来看这个东西怎么弄，是我们这个东西怎么弄。这个东西要搞的话，我们涉及到一些技术处理，以及关键是这个是二维的一个板子，二维的板子要怎么处理的话，我们接下来就给大家看这个东西应该怎么弄。
首先的话在这里针对这个题目本身的话，它的算法的话有好几种给大家首先看：
1. DFS：随便移就行了，每次移的时候就来记它到底要多少zone，它最后的状态是有限的，所以的话你DFS可以
2. BFS：较好的办法是BFS，BFS的话可以得到你第一次这个状态变成最终态的时候，它的步数就是最优解，所以的话它能更快地找到最优解
````
首先的话，这里为了方便存储，一般来说像这种题目，这个棋盘虽然是2X3的，但最后的话会把整个所有的数字，都放在一个字符里面去，把所有的数字变成字符，然后存成一个一维的字符数组，也就是把它存成字符串
class Solution(object):
    def slidingPuzzle(self, board):
        #技术处理：就得到了这么一堆数，这堆数是什么意思。大家可以自己先体会一下。这堆数是什么意思？其实就是它的方向变换向量，就类似四连通图里面的向量或者是八连通图里面的向量。
        moves = {
            0: [1,3],
            1: [0,2,4],
            2: [1,5],
            3: [0,4],
            4: [1,3,5],
            5: [2,4]
        } 
        #初始化
        used = set()#已经访问过的结点
        cnt = 0  
        s = "".join(str(c) for row in board for c in row)  #2X3的数组换成是一维的字符数组，一维字符串
        q = [(s, s.index("0"))]
        while q:
            new = []
            for s, i in q:
                used.add(s)
                if s == "123450"://胜利状态是'123450'
                   return cnt
                arr = [c for c in s]
                for move in moves[i]: //连通
                    new_arr = arr[:]
                    new_arr[i], new_arr[move] = new_arr[move], new_arr[i]
                    new_s = "".join(new_arr)
                    if new_s not in used:
                        new.append((new_s,move))
            cnt +=1
            q = new
        return -1
````
BFS2、BFS3均用python写：见视频，略
3. A* search：最好的一种方法
````
class Solution(object):
    def slidingPuzzle(self, board):
        self.scores = [0]*6   #分数
        goal_pos = {1:(0,0), 2:(0,1), 3:(0,2), 4:(1,0), 5:(1,1), 0:(1,2)}   #目标状态:0-5各个值及其的目标坐标

        for num in range(6): #Pre calculate manhattan distance   #它这个board和需要的终点它的分数到底是多少
            self.scores[num] = [[abs(goal_pos[num][0] - i) + abs(goal_pos[num][1] - j) for j in range(3)] for i in range(2)]    #0-5各个值的处于board的每个坐标到其目标坐标的曼哈顿距离
        #(1,2)  -> [0,0],[0,1],[0,2],[1,0],[1,1],[1,2]
        #(0,0)  -> [0,0],[0,1],[0,2],[1,0],[1,1],[1,2]
        #(0,1)  -> [0,0],[0,1],[0,2],[1,0],[1,1],[1,2]
        #(0,2)  -> [0,0],[0,1],[0,2],[1,0],[1,1],[1,2]
        #(1,0)  -> [0,0],[0,1],[0,2],[1,0],[1,1],[1,2]
        #(1,1)  -> [0,0],[0,1],[0,2],[1,0],[1,1],[1,2]        
        
        Node = namedtuple('Node',['heuristic_score', 'distance', 'board'])
        heap = [Node(0,0,board)]  #优先队列，只要把优先级最高的可以放出来，它可以用heap表示，也可以用priority表示也可以
        closed = []

        while len(heap)>0:   #只要heap不为空
            node = heapq.heappop(heap)
            if self.get_score(node.board) == 0:  #每次从heap里面拿出优先级最高的元素，拿出优先级最高的元素，就算它和终点是不是等于0。如果它和终点的分数等于0，说明什么，说明它和123450完全一模一样，这样的话说明已经到了
                return node.distance  #已经到了，就把distance返回去
            elif node.board in closed:
                continue
            else:
                for neighbor in self.get_neighbors(node.board):  #不然的话就用get_neighbors进行扩散，就是把0的上下左右全部给扩散出来
                    if neighbor in closed: continue
                    heapq.heappush(heap, Node(node.distance+1+self.get_score(neighbor), node.distance+1,neighbor)) #扩散出neighbor，就算出它的优先级，算优先级就用get_score来算优先级，算完的优先级就放到heap里面，接下来放到priority queue里面，继续再找
            closed.append(node.board)
        return -1
    
    def get_neighbors(self,board):
        r, c = (0,board[0].index(0)) if 0 in board[0] else (1,board[1].index(0))
        res = []
        for offr, offc in [[0,1],[0,-1],[1,0],[-1,0]]:  #用四连通图进行上下左右扩散，且来判断这个东西是否超出board。   建议用上面bfs的代码
            if 0 <= r+offr <2 and 0<= c+ offc <3:
                board1 = copy.deepcopy(board)
                board1[r][c], board1[r+offr][c+offc] = board1[r+offr][c+offc],board1[r][c]
                res.append(board1)
        return res
    def get_score(self, board):
        return sum([self.scores[board[i][j]][i][j] for i in range(2) for j in range(3)])  #该状态下的board到目标状态的board值的对应坐标的曼哈顿距离和（score的算法就是用它的坐标差，也同理就是用它的相应的位置坐标之间的差值，来表示它这个score是多少）
````
花花酱 8 Puzzles – Bidirectional A* vs Bidirectional BFS（就是来解决puzzle的问题，它这里不再解决sliding puzzle，而是用这个8 puzzles，那么8puzzles的话它比较了不同的办法，它比较的这些办法的话是哪些，就是Nodes expended: BiDirectional A* /双向A*<< A* (Manhattan) <= Bidirectional BFS/双向BFS < A* Hamming << BFS，Running time: BiDirectional A* < Bidirectional BFS <= A* (Manhattan) < A* Hamming << BFS） ：
https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/

#####3. https://leetcode-cn.com/problems/sudoku-solver/  解数独
没有讲解
####总结
总体来说的话在这一节最难的这一部分的话A*就给大家讲到这里，大家一开始听完这些懵懵懂懂的，我觉得是很正常的。
第一遍听的话第一遍自己，我自己在大二的时候第一遍学的话，也是摸风一样，但是最关键的就是过遍数，你做了第三遍第四遍第五遍的时候，就慢慢可以找到感觉了。
###15. 红黑树和AVL树

####树Tree

####二叉树Binary Tree

#####二叉树遍历Pre-order/In-order/Post-order

####二叉搜索树Binary Search Tree
之前给大家已经提示过，或者是已经打过一个伏笔的，就是树和链表没有本质上的区别，
当一个链表的话，当它分出两个next的话，我们就把它称为树，你可以这么认为。
所以它的数据结构的一个本质就是从一维空间扩散到二维空间了。

#####如何查找

#####极端情况
这种极端情况的话就是在你维护二叉搜索树的时候，没有特殊处理的话，在极端情况下，它会变成一根棍子，这根棍子的话就是你在插入的时候始终插在左边，始终插在左边，当这根棍子出现的时候，二叉搜索树的话就退化成一个链表，就类似于链表的查询的时间复杂度了

#####保证性能的关键
1. 保证二维维度！ -> 左右子树结点平衡（recursively）:左右子树高度尽量是平衡的，且左右子树以此类推下去都尽量是平衡的
2. Balanced：所以这里引入了一个平衡二叉树的概念
3. https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree 维基百科：平衡树
2-3 tree掌握
AA tree
AVL tree掌握
B-tree掌握
Red-black tree掌握
Scapegoat tree
Splay tree了解
Treap了解
Weight-balanced tree

所有的平衡二叉树有很多种，在面试的时候一般喜欢给大家出AVL和红黑树以及比如说treap以及splay叫伸展树，以及后面的话还会有B+树（主要在数据库的索引结构里面用得很多）和二三树，
那么一般来说面试的时候喜欢出这些，但是它整个的话平衡二叉树有很多
#####思考：如何保证一棵树的平衡

####AVL树
1. 发明者 G.M.Adelson-Velsky 和 Evgenii Landis
2. Balance Factor（平衡因子）：
   是它的左子树的高度减去它的右子树的高度（有时相反）。
   balance Factor = {-1,0,1}
注意：记住这里是高度并不是左子树的结点树或者是右子树的结点树，只是它的高度。
      因为查询二叉搜索树的效率只与高度有关，和它这个结点的个数是没有关系的。
      那么就得到了它的平衡因子取值的范围只有-1、0和1这三种。
3. 通过旋转操作来进行平衡（四种）
4. https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree 
#####记录左右子树高度  


#####旋转操作
1. 左旋
子树形态：右右子树->左旋
2. 右旋
子树形态：左左子树->右旋
3. 左右旋
子树形态：左右子树->左右旋
4. 右左旋
子树形态：右左子树->右左旋
######带有子树的旋转
参考动画： https://zhuanlan.zhihu.com/p/63272157

######代码：
不要求掌握

#####AVL总结
1. 平衡二叉搜索树
2. 每个结点存balance factor ={-1,0,1}
3. 四种旋转操作
不足：结点需要存储额外信息、且调整次数频繁

正是这个原因的话，我们就会引入了其它的一些树，这些树的话我们就叫做近似平衡二叉树。
所谓叫近似平衡二叉树就是不需要每次非常严格地来平衡
近似平衡二叉树：
####红黑树
#####Red-Black Tree
红黑树是一种近似平衡的二叉搜索树（Binary Search Tree），它能够确保任何一个结点的左右子树的高度差小于两倍。
具体来说，红黑树是满足如下条件的二叉搜索树：
- 每个结点要么是红色，要么是黑色
- 根结点是黑色
- 每个叶结点（NIL结点，空结点/叶结点即指树尾端NIL指针或NULL结点）是黑色的
- 不能有相邻接的两个红色结点/如果一个结点是红的，那么它的俩个儿子都是黑的
- 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点/对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点

#####对比
有待翻译（见视频）
- AVL trees provide FASTER LOOKUPS than Red Black Trees because they are MORE STRICTLY BALANCED
- Red Black Trees provide FASTER INSERTION AND REMOVAL operations than AVL trees as fewer rotations are done due to relatively relaxed balancing 
- AVL trees store balance FACTORS OR HEIGHTS with each node, thus requires storage for an integer per node whereas Red Black Tree requires only 1 bit of information per node
- Red Black Trees are used in most of the LANGUAGE LIBRARIES LIKE MAP, MULTIMAP. MULTISETIN C++ whereas AVL trees are used in DATABASES where faster retrievals are required


##二、学习总结：
###1.效果、感受
 本周进度有所延迟，视频中高级搜索没有来得及看、其他两课虽然看了但是笔记没有做全，感觉第7周开始每周的时长比上半学期要多出一课的时长。
 ###2.学习过程
 先看录播，边看录播边做笔记，把笔记和每周的学习总结放到一个markDown文档里面，然后着手习题，用习题来检验学习效果。
 ###3.收获
 这七周对数组、链表、队列、栈、堆、图、递归、分治、回溯、dfs、bfs、贪心算法、二分查找、动态规划、Trie树、并查集、高级搜索、AVL树、红黑树均有一定掌握，但是由于底子较薄，只是建立初步印象，需要花更多时间去掌握。
 ###4.刷题笔记
 略