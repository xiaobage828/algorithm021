#第五周 
##一、学习笔记
###前半学期内容
####前半程:
#####成就表
推荐网站：Visualgo.net
Array/数组
Linked List/链表（动画）有复习:
Stack/栈
Queue/队列
HashTable/哈希表（动画）有复习:
Set、Map
Tree/二叉树
BST/二叉搜索树（动画）有复习：，左子树全部节点是小于根，右子树全部节点大于根，且对于左右子树同理可得，另外中序遍历是什么顺序的（递增），同时，空树也是二叉搜索树
Search/查询
Recursion/递归（动画）有复习：算n的阶乘（线性结构），Fibonacci数列（每一层调用，会调用两次，递归树每一层一分为二，就是二叉树，如果递归调用三次，那么就是三叉树以此类推。Fibonacci数列它的递归的状态树是什么样子？是一棵二叉树，同时的话每一层一分为二，所以节点数是乘2。整个它的状态空间是呈指数级增长，也就是它的时间复杂度是指数级的，这个就是递归的一种形式）
DFS/深度优先搜索
BFS/广度优先搜素
Divide & Conquer/分治
Backtracking/回溯
Greedy/贪心
Binary Search/二叉查找
####后半程：高级数据结构+高级算法
比如说有动态规划，以及有一些高级的分治算法，还有一些比如说是字典序、并查集和位运算
####坚持:
1. 五毒神掌
2. 脑图 + 笔记总结
3. 微信群里多交流
####失败只有一种，就是半途而废! 比别人多一点执着，你就会创造奇迹！
###前序知识
讲之前先复习这几个较为复杂的数据结构：分治+回溯+递归+动态规划，
伏笔：本质是将一个复杂的问题，分解成各种子问题，同时寻找它的重复性。不管是分治回溯递归还是动态规划，它们并没有本质上的非常大的不一样。很多时候就是一些小的细节的问题，这里先回顾一下分治、回溯和递归
递归：（代码模板）见7.1笔记
分治：其实也是递归 （代码模板）见8.1笔记
大家要形成这样一个
####感触：
1. 人肉递归低效、很累：人肉递归怎么弄，把递归树给画出来
2. 找到最近最简方法，将其拆解成可重复解决的问题
3. 数学归纳法思维（抵制人肉递归的诱惑）
####本质：寻找重复性->计算机指令
人肉递归怎么弄，把递归树给画出来：
例如：Fib(6) 状态树、重复子状态
###动态规划Dynamic Programming
动态规划的话，英文名叫做dynamic programming，中文的翻译的话非常玄乎叫动态规划，那么其实它本质上要解决的问题就是一个递归问题或者是分治问题，但是它和普通的递归分治稍微有一点不一样，就是这里等一下要给大家讲的第三点，它拥有所谓的最优子结构，最优子结构的话翻译得也很玄乎，所以动态规划很多同学就经常会问，
超哥这个好难搞，或者是我经常看了很多遍，最后为什么。因为中文翻译的话比较玄学。
dynamic programming:programming其实和规划超哥觉得没有太大的关系，这里的programming，其实指的是一种写程序的办法，或者就是动态递推，programming很多时候在这里是推导的意思，所以你可以理解为动态递推即可
动态规划和最优子结构
1.Wiki定义: https://en.wikipedia.org/wiki/Dynamic_programming
2.Wiki定义最关键的一句话："Simplifying a complicated problem by breaking it down into simpler sub-problems"(in a recursive manner) 
指的是将一个复杂的问题，把它分解成简单的子问题，它的定义里面还会加了一个括号，就是in a recursive manner，指的是用一种递归的方式。
所以在Wiki的DP的定义里面，它就给大家明确说了，你需要进行分治，在这里可以看到，DP和分治它们是有内在联系的，它们并不是完全割裂的两个算法，
那么它和分治很多时候本质的一个区别，或者是明显的一个地方要注意的是什么，就是第三点在这里
一般来说动态规划的问题，它会是让你求一个最优解，或者求一个最大值，或者求一个最少的方式这样，
正是因为它有所谓的这种最优子结构存在的话，那么你在中间的每一步的话就不需要把所有的状态都保存下来，你只需要存最优的状态，
当然你还需要证明，如果我每一步都存着相当于最优的值，最后的话我就能够推导出一个全局的最优的值，
那么正式因为这样的话，就是引入了两个，一个的话就是有所谓的缓存了，或者是说状态的存储数组
第二个的话就是在每一步的话都会把次优的状态给淘汰掉，只保留在这一步里面最优或者是较优的一些状态来推导出最后的全局最优
3.Divide & Conquer + Optimal substructure 分治+最优子结构
####关键点：非常重要
动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）
共性：找到重复子问题
差异性：最优子结构、中途可以淘汰次优解

动态规划Dynamic Programming，或者叫DP它的本质就是动态递推，那么根据它的概念和我们后面要讲的习题，大家慢慢会体会到动态规划和递归或者分治没有本质上的区别，关键是看有无最优的子结构。
如果没有最优的子结构说明什么？说明所有的子问题，你都需要计算一遍，同时把最后的结果给合并在一起，所以我们传统意义上就称之为分治（有些同学可能会问我非要叫动态规划行不行，其实也可以，就是因为你可以理解为每次的最优解就是当前解就行了，它没有所谓的每次比较和淘汰的一个过程，对吧，但一般传统意义上我们就称之为分治）
所以这里的共性就是找到重复的子问题，
那么差异是什么地方？就是动态规划和递归分治的差异是：动态规划一般我们认为就是有最优子结构的，中途的话可以淘汰次优解，当然也必须淘汰次优解，
如果你把次优解都保存下来的话，那么你会发现你要做的事情的复杂度，就会比淘汰次优解来得更多了。
那么因为这个原因的话，所以动态规划很多时候是复杂度更低的，或者是更加有效的。
那么后面大家见的题目多了，你就会发现如果你不进行淘汰的话，你傻递归，我们叫做啥递归或者傻分治的话，经常是指数级的时间复杂度，
但是如果你进行了所谓的淘汰次优解，那么经常会变成n的平方或者是O(n)的时间复杂度，也就是从指数级把复杂度降到了多项式级别