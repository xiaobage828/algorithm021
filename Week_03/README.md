#第三周 
##一、学习笔记
###7.1泛型递归、树的递归
之前讲了关于树的，发现很多时候，树的数据结构很多都是递归型的定义，所以这一课我们重点来讲递归，也就是所谓的泛型递归以及关于树的各种递归。
1. 前序知识回顾：
树的面试题解法一般都是递归，为什么？1.节点的定义：它的结点和树本身，它数据结构的定义，就是用递归的方式来进行的。2.重复性（自相似性）不仅是树本身、二叉树以及搜索二叉树，它在定义它数据结构和它的算法特性的时候，也是用所谓的重复性，也就是自相似性。
比如说二叉搜索树的话，就会是左子树都要小于根结点，右子树都要大于根结点，且左右子树具有相似的特征；或者是说以此类推左右子树也满足以上特点。

那么递归本身的话具体有哪些要注意的点，和它本身的特点，以及相应的递归的面试题会是什么，这就是我们这一节课的重点所在
2. 递归Recursion
递归-循环
通过函数体来进行的循环（递归其实本质上它就类似于循环，只不过是通过循环体调用自己，来进行所谓的循环）
为什么会有这样的一种形式？
就是因为在计算机语言在创造的时候，它本质上就是汇编嘛，而汇编的话，它有个特点，就是说它没有所谓的循环嵌套这么一说，很多时候它更多的用的就是，你之前有一段函数写在什么地方，或者你一段指令写在什么地方，你就直接不断地反复跳到之前的那段指令，不断地去执行，其实这就是所谓的递归。
而循环本身的话，你可以把它编译出来，你看它的汇编代码的话，其实和递归本身的话有异曲同工之处。所以递归和循环他们没有明显的边界
递归从现实意义上讲的话，就是我们小时候讲的最多的一个故事
1.从前一个山
2.山里有个庙
3.庙里有个和尚讲故事
4.返回1
可以发现，在我们现实生活中，很多时候也有所谓的重复性，而这种重复性的话，其实用计算机解决的话，就能够给大家省很多的事情
找到这种归去来兮的感觉，类比：盗梦空间
递归的特点：
- 向下进入到不同梦境中；向上又回到原来一层（一般来说它不能直接跳跃，而是必须一层一层地下，然后一层一层的回来，所谓的就是有一种对称性，或者叫做归去来兮的感觉）
- 通过声音同步回到上一层（所谓这种同步的关系就是用参数来进行，函数不同层之家的传递变量）
- 每一层的环境和周围的人都是一份拷贝、主角等几个人穿越不同层级的梦境，发生和携带变化
 （也就是他进到每一层的话，这每一层的房子建筑和那些电脑，我们所谓的无关的人物的话，其实就是你就类似，于是硬生生地整个创造了一份新的世界，你把这个世界全部都打坏了之后，你去到下一层，或者是回到上一层，上一层的世界里面的楼，还是不受影响的，一般来说是这样的。
 然而主角等几个人的话就是主角那个团队，他可以穿越不同的梦境，同时把自身和自己所要携带的东西，都可以带到不同的梦境里面去发生变化，且把变化可以携带回来。
 而这样主角团队，这个就类似于函数里面的参数，同时还会有一些全局变量）
通过现实中盗梦空间的这样一个跳跃的含义，给大家说一下递归的话它整个发生和现实中怎么联系在一起的
那么这三点的话，我希望大家自己在脑子里面多思考一下，思考好了之后，平时在做类似于题目的时候、写程序的话都想到盗梦空间，来想一下自己怎么弄
3. 最简单的递归：计算n!  （递归栈见视频）
写一个函数即可，每次就括它自己掉n-1。那么递归它最后的运行方式的话就成了这么一个所谓的递归栈，就一层一层展开，而这种形式的话就是更像一种剥洋葱的形式，
所谓剥洋葱类似于一个栈的形式一层一层一层进去，然后把它剥开，而栈本身的话就是递归调用的时候，它系统就给我们做了一个这样的调用栈
4. 参考链接：递归的代码模板https://shimo.im/docs/EICAr9lRPUIPHxsH/read
递归终结条件->处理当前层逻辑->下探到下一层->清理当前层
-- Python
def recursion(level, param1, param2, ...): 
    <!-- recursion terminator -->
    if level > MAX_LEVEL: 
	   process_result 
	   return 
    <!-- process logic in current level --> 
    process(level, data...) 
    <!-- drill down -->
    self.recursion(level + 1, p1, ...) 
    <!-- reverse the current level status if needed -->

// Java  本身的话代码不长，结构的话更加重要，记住这四个结构模块，总共的话就是四块，整个递归代码
public void recur(int level, int param) { 
  // 第一部分的话就叫recursion terminator：递归终结条件（也就是写递归函数开始的话，一定要记得先把函数就是递归终止条件给写上。这一点的话如果不注意的话，最后造成的结果就是无限递归或者叫做死循环。类似于死递归之类的，就这个函数出不来了，你就只能强行把这个程序给杀掉）
  if (level > MAX_LEVEL) { 
    // process result 
    return; 
  }
  // 第二部分：process logic in current level ：处理当前层逻辑（就是你到了这一层，这个递归的层次的话，你要处理这一层要进行的逻辑就在这里的话，完成这一层要进行的业务代码逻辑代码）
  process(level, param); 
  // 第三部分：drill down ：下探到下一层（下到下一层的话，这里的话，它的参数来标记当前是哪一层，就level这里level就必须加一，同时把相应的参数p1p2p3放下去就行）
  recur( level: level + 1, newParam); 
  //第四部分：reverse/restore/clean/store the current level status if needed ：清理当前层
  //（要是递归完了，最后一部分你这一层有些东西可能要清理，就把它清理。
  //有些时候我们不需要清理这一层，因为的话它这一层的很多时候，它这一层本身的那些环境的话，它是拷贝一份出来的，对吧。
  //但很多时候的话会有一些全局变量，还有其他的一些事情你要进行清理的，那你就在最后这一部分来进行清理即可）
}

// C/C++
void recursion(int level, int param) { 
  // recursion terminator
  if (level > MAX_LEVEL) { 
    // process result 
    return ; 
  }

  // process current logic 
  process(level, param);

  // drill down 
  recursion(level + 1, param);

  // reverse the current level status if needed
}

// JavaScript
const recursion = (level, params) =>{
   // recursion terminator
   if(level > MAX_LEVEL){
     process_result
     return 
   }
   // process current level
   process(level, params)
   //drill down
   recursion(level+1, params)
   //clean current level status if needed
   
}
5. 思维要点
递归难以领悟或者难以理解的话，对症下药（提的三点，大家要注意的）
1.不要人肉进行递归（最大误区）：这一点主要是针对如果大家后来递归开始慢慢比较熟练了之后，一定要抛弃这样的习惯，就是不要再进行人肉递归了。如果你刚开始学的话，你可以在纸上把递归所进行的状态，也就所谓的递归的状态树画出来可以。但是在后面的话，我希望大家主动抛弃人肉递归，以及要画递归的状态树这么一种特点。你一定要记得直接看函数本身开始写即可，不然的话你永远没法有效地掌握，或者是熟练地使用递归
2.找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）：为什么要找最近重复子问题？就是因为我们写的程序的指令，只包括if else然后for和while loop，然后就是第三部分的话，就是递归调用。正是因为我们所有的代码，只有这三部分，所以最后你的程序肯定，如果是比较复杂的程序，你个人觉得比较复杂，不就是它逻辑相对来说比较多。逻辑比较多，但却可以用，比如说五行语句或者十行语句解决。为什么？就是因为这个很复杂，你觉得很多的逻辑本身的话，有所谓的可重复性
3.数学归纳法思维：其实就和上面是一样的。数学归纳法的要点：就是最开始最简单的条件是成立的，比如说n=1、n=2的时候是成立的，且第二点你能够证明当n成立的时候，可以推导出n+1也成立的。那么就类似于放鞭炮一样，第一个我保证可以我把它点燃，同时我还可以保证前一个炮竹炸的时候，后一个炮竹也会炸。那么这一串炮竹一百响，或者是一千向的炮竹，只要我点燃第1颗，后面肯定都可以证明能够爆炸的。
这就是所谓的递归的理论部分

6. 注意
1. 4链接中的代码模板认真去看，然后记下来，一定要养成机械化的记忆。也就是说一开始写递归的话，这个模板啪啪啪四部分马上写下来。这四部分脑子里面也很清楚
2. 5三个思维的要点：大家一定注意 一、抵制人肉递归的诱惑，二、找最近重复性，三、数学归纳法的思维
###7.2爬楼梯、括号生成等问题
####思维要点
1. 不要人肉进行递归（最大误区）
2. 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
3. 数学归纳法思维
所有递归的题目要干嘛？这三点找最近重复性中间的这样
第二点，如果它本身很复杂，就是说没有任何重复性的话。有没有可能没有任何重复性？
假设没有任何重复性的话，就说明它的复杂度是客观存在的。有多少复杂的逻辑的话，就写多少复杂的代码，代码就是几千行几万行都有可能，这种情况的话的确只能这样
不过话说回来，所有的面试题的话，基本上就是在五行十行最多二十行以下可以完成的，说明它肯定有所谓的重复性
####climbing-stairs
数学归纳法





####generate-parentheses
优秀题解：光头哥，StefanPochmann

实战题
#### invert-binary-tree/description
#### validate-binary-search-tree 
难：递归，BST-->中序遍历是递增的
#### maximum-depth-of-binary-tree（高频题）
难：找出重复性：最大深度：左子树的深度+root，右子树的深度+root。。。
#### minimum-depth-of-binary-tree 
####serialize-and-deserialize-binary-tree

####homework
1. lowest-common-ancestor-of-a-binary-tree：二叉树最近公共祖先（高频老题）
2. contruct-binary-tree-from-preorder-and-inorder-traversal
3. combinations排列/组合
4. permutations
5. permutations-li